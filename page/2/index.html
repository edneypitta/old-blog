<!doctype html>
	<!--[if !IE]>
	<html class="no-js non-ie" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if IE 7 ]>
	<html class="no-js ie7" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if IE 8 ]>
	<html class="no-js ie8" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if IE 9 ]>
	<html class="no-js ie9" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if gt IE 9]><!-->
<html class="no-js" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <!--<![endif]-->
<head>
<base href="https://edneypitta.github.io/old-blog" />

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">



<title>Edney Pitta - Página 2 de 5 - Descomplicando a Carreira de Programador</title>

<!-- This site is optimized with the Yoast SEO plugin v3.0.7 - https://yoast.com/wordpress/plugins/seo/ -->
<meta name="description" content="O blog Edney Pitta - Descomplicando a Carreira de Programador vai te ajudar a saber onde você está na sua carreira, quais são suas atuais opções e como elas vão impactar seu futuro."/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://edneypitta.github.io/old-blog/page/2/" />

<link rel="next" href="https://edneypitta.github.io/old-blog/page/3/" />
<meta property="og:locale" content="pt_BR" />
<meta property="og:type" content="website" />
<meta property="og:title" content="Edney Pitta" />
<meta property="og:description" content="Descomplicando a Carreira de Programador" />
<meta property="og:url" content="https://edneypitta.github.io/old-blog/page/2/" />
<meta property="og:site_name" content="Edney Pitta" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:description" content="O blog Edney Pitta - Descomplicando a Carreira de Programador vai te ajudar a saber onde você está na sua carreira, quais são suas atuais opções e como elas vão impactar seu futuro."/>
<meta name="twitter:title" content="Edney Pitta - Página 2 de 5 - Descomplicando a Carreira de Programador"/>
<meta name="twitter:site" content="@edneypitta"/>
<script type='application/ld+json'>{"@context":"http:\/\/schema.org","@type":"WebSite","url":"http:\/\/edneypitta.github.io\/","name":"Edney Pitta","alternateName":"Descomplicando a Carreira de Programador","potentialAction":{"@type":"SearchAction","target":"http:\/\/edneypitta.github.io\/?s={search_term_string}","query-input":"required name=search_term_string"}}</script>
<script type='application/ld+json'>{"@context":"http:\/\/schema.org","@type":"Person","url":"http:\/\/edneypitta.github.io","sameAs":["https:\/\/www.facebook.com\/edneypitta","https:\/\/br.linkedin.com\/in\/edneypitta","https:\/\/twitter.com\/edneypitta"],"name":"Edney Pitta"}</script>
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='//fonts.googleapis.com' />
<link rel='dns-prefetch' href='//s.w.org' />


		<script type="text/javascript">
			
			
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='sparkling-bootstrap-css'  href='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/css/bootstrap.min.css?ver=4.8.2' type='text/css' media='all' />
<link rel='stylesheet' id='sparkling-icons-css'  href='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/css/font-awesome.min.css?ver=4.8.2' type='text/css' media='all' />
<link rel='stylesheet' id='sparkling-fonts-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A400italic%2C400%2C600%2C700%7CRoboto+Slab%3A400%2C300%2C700&#038;ver=4.8.2' type='text/css' media='all' />
<link rel='stylesheet' id='sparkling-style-css'  href='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/style.css?ver=4.8.2' type='text/css' media='all' />
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/modernizr.min.js?ver=4.8.2'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/bootstrap.min.js?ver=4.8.2'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/functions.min.js?ver=4.8.2'></script>
<link rel='https://api.w.org/' href='https://edneypitta.github.io/old-blog/wp-json/' />

 

<script data-cfasync="false" src="//load.sumome.com/" data-sumo-site-id="025f16b2b72012bef5c86b74ea4d0bd0652e8245a2df8c61ed302458c0f98f3b" async></script><style type="text/css">.entry-content {font-family: Open Sans; font-size:14px; font-weight: normal; color:#6B6B6B;}.navbar > .container .navbar-brand {
font-size: 35px;
margin-top: 7px;
}

#menu-social i{
font-size:17px;
}
#menu-social-1 i {
font-size:22px;
}

article ul {
    list-style: none;
    padding:0;
    margin:0;
margin-bottom: 10px;
}

article li { 
    padding-left: 1em; 
    text-indent: -.7em;
}

article li:before {
    content: "\2022";
    color: rgb(191, 66, 78); 
padding-right:7px;
font-size: 15px;
}

#logo {
margin: 10px 0px;
}

.textwidget a:hover h2{
color:#c9302c;
}</style>	<style type="text/css">
			.navbar > .container .navbar-brand {
			color: #ffffff;
		}
		</style>
	<link rel="icon" href="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-32x32.png" sizes="32x32" />
<link rel="icon" href="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-180x180.png" />
<meta name="msapplication-TileImage" content="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-270x270.png" />

<script type="text/javascript">
jQuery(document).ready(function()
{
jQuery('.fa-linkedin-square').parent().attr('target', '_blank').attr('title', 'LinkedIn');
jQuery('.fa-facebook-square').parent().attr('target', '_blank').attr('title', 'Facebook');
jQuery('.fa-twitter-square').parent().attr('target', '_blank').attr('title', 'Twitter');
jQuery('.fa-rss').parent().attr('target', '_blank').attr('title', 'RSS');

jQuery('.fa-info-circle').parent().attr('title', 'Sobre');
});
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66613004-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<body class="home blog paged paged-2">
<div id="page" class="hfeed site">

	<header id="masthead" class="site-header" role="banner">
		<nav class="navbar navbar-default" role="navigation">
			<div class="container">
				<div class="row">
					<div class="site-navigation-inner col-sm-12">
						<div class="navbar-header">
							<button type="button" class="btn navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
								<span class="sr-only">Toggle navigation</span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
							</button>

							
							<div id="logo">
								<a href="https://edneypitta.github.io/old-blog/"><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-edneypitta-oficialissimo-fundo-branco.png"  height="84" width="411" alt="Edney Pitta"/></a>
							</div><!-- end of #logo -->

							
							
						</div>
						<div class="collapse navbar-collapse navbar-ex1-collapse"><ul id="menu-social" class="nav navbar-nav"><li id="menu-item-20" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-20"><a title="&lt;i class=&quot;fa fa-linkedin-square&quot;&gt;&lt;/i&gt;" href="https://br.linkedin.com/in/edneypitta"><i class="fa fa-linkedin-square"></i></a></li>
<li id="menu-item-22" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-22"><a title="&lt;i class=&quot;fa fa-facebook-square&quot;&gt;&lt;/i&gt;" href="https://www.facebook.com/edneypitta"><i class="fa fa-facebook-square"></i></a></li>
<li id="menu-item-23" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-23"><a title="&lt;i class=&quot;fa fa-twitter-square&quot;&gt;&lt;/i&gt;" href="https://twitter.com/edneypitta"><i class="fa fa-twitter-square"></i></a></li>
<li id="menu-item-24" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-24"><a title="&lt;i class=&quot;fa fa-rss&quot;&gt;&lt;/i&gt;" href="https://edneypitta.github.io/old-blog/feed/"><i class="fa fa-rss"></i></a></li>
<li id="menu-item-27" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-27"><a title="&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt;" href="https://edneypitta.github.io/old-blog/sobre/"><i class="fa fa-info-circle"></i></a></li>
</ul></div>					</div>
				</div>
			</div>
		</nav><nav class="navbar navbar-default" role="navigation">				<div class="container">					<div class="row">						<div class="col-sm-12" style="padding-bottom:10px">							<h2 style='color:#faebcc'><i class="fa fa-exclamation-circle" aria-hidden="true"></i> Novo blog: <a href="https://edneypitta.com" style='color:#faebcc'>https://edneypitta.com</a></h2>						</div>					</div>				</div>			</nav>
	</header><!-- #masthead -->

	<div id="content" class="site-content">

		<div class="top-section">
								</div>

		<div class="container main-content-area">
			<div class="row">
				<div class="main-content-inner col-sm-12 col-md-8 pull-left">

	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
						
				
<article id="post-538" class="post-538 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-5-consume-web-api-web-services/" title="Certificação Microsoft 70-487: Objetivo 4.5 &#8211; Consume Web API web services" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-5-consume-web-api-web-services/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.5 &#8211; Consume Web API web services</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-5-consume-web-api-web-services/" rel="bookmark"><time class="entry-date published" datetime="2016-03-02T15:56:28+00:00">02/03/2016</time><time class="updated" datetime="2016-03-03T00:34:48+00:00">03/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-5-consume-web-api-web-services/#respond"><span class="dsq-postid" data-dsqidentifier="538 https://edneypitta.github.io/old-blog/?p=538">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
O objetivo <strong>Consume Web API web services</strong>, o último sobre Web API, cobre como consumir serviços Web API usando HttpClient e mandar e receber requests em formatos diferentes.</p>
<h2>Consumindo Serviços Web API</h2>
<p>A classe <em>HttpClient</em> é usada para fazer requisições e trabalhar com o retorno. Para os exemplos dessa seção, vamos utilizar o seguinte método como setup:</p>
<p><script src="https://gist.github.com/edneypitta/b94e54f60eaeed11bddc.js"></script></p>
<p>Vamos passar pelos 4 métodos HTTP mais comuns: Get, Post, Put e Delete, além de aprender como lidar com exceções.</p>
<h4>HttpGet</h4>
<p>Para fazer um Get, o método <em>GetAsync</em> do HttpClient é usado. Não há um equivalente síncrono, somente o método Async.<br />
Após o retorno da operação, a propriedade <em>IsSuccessStatusCode</em> é populada. O código ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/faf5810261b4c0ec76a0.js"></script></p>
<p>O método <em>ReadAsAsync</em> é um método de extensão, implementado no assembly <em>System.Net.Http.Formatting</em>.</p>
<h4>HttpPost</h4>
<p>Para executar um Post, você pode usar os métodos <em>PostAsync </em>e <em>PostAsJsonAsync</em>, que simplifica as coisas caso o Content-Type seja JSON. A implementação é bem simples:</p>
<p><script src="https://gist.github.com/edneypitta/7a176ad23ca879c189c8.js"></script></p>
<h4>HttpPut</h4>
<p>Um Put pode ser feito praticamente da mesma forma que um Post. Há os métodos <em>PutAsync </em>e <em>PutAsJsonAsync</em>:</p>
<p><script src="https://gist.github.com/edneypitta/3f2bc033d6d1cd944078.js"></script></p>
<h4>HtpDelete</h4>
<p>O método <em>DeleteAsync</em> faz um Delete. O método apenas recebe uma string com a URL, já com o identificador do item a ser deletado:</p>
<p><script src="https://gist.github.com/edneypitta/ec456452d34e05d5a3b7.js"></script></p>
<h4>Exceções</h4>
<p>Exceções podem ocorrer ao chamar um serviço Web API. </p>
<p>Nesses casos, porém, na chamada ao método que fez a operação (GetAsync, PostAsync, etc.), a exceção não é automaticamente lançada. Você deve explicitamente chamar o método <em>EnsureSuccessStatusCode</em> para que isso aconteça.</p>
<p>Veja os seguintes trechos de código. O primeiro não lança a exceção, enquanto o segundo faz:</p>
<p><script src="https://gist.github.com/edneypitta/69e21acaa29399ed443d.js"></script></p>
<h2>Mandando E Recebendo Requests Em Formatos Diferentes</h2>
<p>Há algumas opções em relação aos formatos aceitos pelo framework Web API. Isso inclui <em>application/xml</em>, <em>text/html</em>, <em>image/png</em>, <em>application/json</em>, etc. </p>
<p>Esses valores são retornados no header Content-Type dos responses, indicando o tipo do retorno. Eles também podem ser usados no header Accept para que o client especifique o tipo do retorno que ele quer receber. Nesses headers, múltiplos valores são aceitos sendo separados por vírgula.</p>
<p>É possível também implementar formatos customizados. Você pode fazer isso herdando das classes <em>MediaTypeFormatter</em> ou <em>BufferedMediaTypeFormatter</em>. A principal diferença entre elas é MediaTypeFormatter suporta a leitura assíncrona, enquanto BufferedMediaTypeFormatter suporta somente leituras síncronas.</p>
<p>Primeiro, você deve herdar da classe desejada e adicionar o media type a ser suportado na coleção <em>SupportedMediaTypes</em>:</p>
<p><script src="https://gist.github.com/edneypitta/52fa0de34dc65324ce45.js"></script></p>
<p>Você precisa também adicionar seu formatter customizado no HttpConfiguration: <code>config.Formatters.Add(new CustomCsvFormatter());</code>.</p>
<p>Depois, você implementa sua lógica na classe criada. As propriedades <em>CanWriteType</em> e <em>CanReadType</em> devem ser sobrescritas, indicando se o tipo pode ser serializado e desserializado. O método <em>WriteToStream</em> também deve ser implementado e se o formatter suportar desserialização (CanReadType true), o método ReadFromStream precisa ser implementado.</p>
<p>Detalhes sobre a implementação não cairão no exame, mas é bom seguir o exemplo da documentação para ter uma ideia melhor de como implementar um formatter customizado: <a href="http://www.asp.net/web-api/overview/formats-and-model-binding/media-formatters" target="_blank">http://www.asp.net/web-api/overview/formats-and-model-binding/media-formatters</a>.</p>
<hr />
<p>E encerramos o capítulo sobre Web API 😀</p>
<p>O próximo post será sobre o objetivo 5.1, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-5-1-design-a-deployment-strategy/">Design a deployment strategy</a></strong>. Esse é o primeiro objetivo do último tópico da certificação.</p>
<p>Obrigado e até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-5-consume-web-api-web-services/" title="Certificação Microsoft 70-487: Objetivo 4.5 &#8211; Consume Web API web services">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-526" class="post-526 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-4-host-and-manage-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.4 – Host and manage a Web API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-4-host-and-manage-a-web-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.4 – Host and manage a Web API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-4-host-and-manage-a-web-api/" rel="bookmark"><time class="entry-date published" datetime="2016-03-02T11:44:00+00:00">02/03/2016</time><time class="updated" datetime="2016-03-02T15:57:24+00:00">02/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-4-host-and-manage-a-web-api/#comments"><span class="dsq-postid" data-dsqidentifier="526 https://edneypitta.github.io/old-blog/?p=526">1 Comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
O objetivo 4.4 da certificação Microsoft 70-487, <strong>Host and manage a Web API</strong>, trata dos principais mecanismos de hospedagem de um serviço Web API, como self-hosting, IIS e Azure. Também mostra como limitar o tamanho das mensagens recebidas e configurar a hospedagem para streaming. Vamos lá?</p>
<h2>Web API Self-Hosting</h2>
<p>Para fazer o self-hosting de uma Web API, você pode usar qualquer template de projeto que crie um executável, como Windows Service, Windows Forms Application, Console Application, etc. </p>
<p>Com o projeto criado, você deve instalar o framework de self-hosting via NuGet com o pacote <em>Microsoft ASP.NET Web API Self Host</em> e referenciar os assemblies <em>System.Web.Http</em> e <em>System.Web.Http.SelfHost</em>:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/12.png" alt="self host" width="727" height="488" class="alignnone size-full wp-image-530" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/12.png 727w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/12-300x201.png 300w" sizes="(max-width: 727px) 100vw, 727px" /></p>
<p>Depois, há dois passos essenciais: instanciar as classes <em>HttpSelfHostConfiguration </em>e <em>HttpSelfHostServer</em>. O código fica assim:</p>
<p><script src="https://gist.github.com/edneypitta/a23737585b6d138a4f70.js"></script></p>
<p>A primeira verificação se <em>MyWebApi.Controllers.ValuesController</em> é null serve para o framework de self-hosting carregar os controllers do seu projeto Web API. Isso somente é necessário quando os controllers estão num assembly separado.</p>
<p>A classe HttpSelfHostConfiguration recebe o endereço base de onde o serviço vai ser acessado. Um ponto importante aqui é que as rotas precisam ser configuradas diretamente na propriedade Routes.</p>
<p>Por último, a classe HttpSelfHostServer é instanciada recebendo a configuração criada anteriormente. O método OpenAsync toma conta de abrir o servidor com as configurações passadas.</p>
<h2>Web API IIS Hosting</h2>
<p>Hospedar uma Web API no IIS não tem nada diferente de outras aplicações web. </p>
<p>Você pode primeiro criar uma application pool, conforme abaixo:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/13.png" alt="application pool" width="293" height="266" class="alignnone size-full wp-image-531" /></p>
<p>Depois, criar um novo website embaixo do nodo Sites ou adicionar uma aplicação ou diretório virtual:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/14.png" alt="add application" width="426" height="316" class="alignnone size-full wp-image-532" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/14.png 426w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/03/14-300x223.png 300w" sizes="(max-width: 426px) 100vw, 426px" /></p>
<p>Com tudo isso no lugar, sua aplicação deve estar hospedada com sucesso.</p>
<h2>Web API Windows Azure Hosting</h2>
<p>Essa é uma seção conceitual para as 3 formas de hospedar uma Web API no Azure. São elas:</p>
<ul>
<li><strong>Windows Azure Websites</strong>: a opção mais rápida. Com Azure Websites você não se importa com a máquina que está hospedando seu serviço, apesar de poder escalar sua aplicação facilmente;</li>
<li><strong>Windows Azure Cloud Services</strong>: Cloud Services oferecem um controle maior. Você tem mais tamanhos de instância para escolher e pode criar uma arquitetura mais complexa, como uma Web API numa Web Role se comunicando via queue com uma Worker Role, por exemplo. Você pode também configurar o IIS e outras configurações da máquina quando a role começar. Consegue também se conectar via remote com a máquina;</li>
<li><strong>Windows Azure Virtual Machines (VMs)</strong>: usar VMs no Azure te dá controle completo. Você precisa gerenciar sua máquina inteira, de atualizações até configurações.</li>
</ul>
<p>Fazer o deploy de uma Web API para o Azure Websites ou Cloud Services é bem simples usando o Visual Studio. Isso será coberto com mais detalhes no capítulo 5.</p>
<h2>Limitando O Tamanho Das Mensagens</h2>
<p>Ao hospedar sua Web API, você com certeza gostaria de limitar o tamanho dos requests para que seu servidor não sofra de ataques DDoS.</p>
<p>Usando self-hosting, você pode fazer isso setando as propriedades <em>MaxReceivedMessageSize </em>e <em>MaxBufferSize </em>do objeto HttpSelfHostConfiguration:</p>
<p><code>var config = new HttpSelfHostConfiguration(baseAddress);<br />
config.MaxReceivedMessageSize = 1024;<br />
config.MaxBufferSize = 1024;</code></p>
<p>Hospedando no IIS, isso é possível pela configuração do atributo <em>maxRequestLength </em>no web.config:</p>
<p><code>&lt;httpRuntime maxRequestLength=&quot;1024&quot; /&gt;</code></p>
<h2>Configurando Streaming</h2>
<p>Às vezes você quer que seu serviço Web API receba arquivos grandes, como algum upload de imagens ou vídeos. Nesses casos, é importante configurar sua Web API para usar streaming ao invés de buffer, já que bufferizar arquivos grandes consome muita memória.</p>
<p>Hospedando sua aplicação no IIS, você consegue implementar sua lógica se usar buffer ou streaming herdando a classe <em>WebHostBufferPolicySelector</em>, a única que implementa a interface <em>IHostBufferPolicySelector</em>, e sobrescrevendo o método <em>UseBufferedInputStream</em>. Por exemplo, você pode habilitar streaming apenas para um controller específico:</p>
<p><script src="https://gist.github.com/edneypitta/9a95eee1e58dd24ea54f.js"></script></p>
<p>Depois disso, você deve configurar o HttpConfiguration para usar sua implementação: <code>config.Services.Replace(typeof(IHostBufferPolicySelector), new StreamingPolicySelector());</code>.</p>
<p>Por último, você precisa configurar as propriedades do ASP.NET como <em>maxAllowedContentLength </em>e <em>maxRequestLength </em>no web.config para que o IIS não rejeite os requests grandes:</p>
<p><script src="https://gist.github.com/edneypitta/850bf2e6b8cdaed226a0.js"></script></p>
<p>Para self-hosting, você só consegue habilitar streaming para todos os controllers. Você faz isso configurando a propriedade <em>TransferMode</em> no objeto HttpSelfHostConfiguration:</p>
<p><code>// somente requests<br />
selfHostConf.TransferMode = TransferMode.StreamedRequest;<br />
// somente responses<br />
selfHostConf.TransferMode = TransferMode.StreamedResponse;<br />
// ambos<br />
selfHostConf.TransferMode = TransferMode.Streamed;</code></p>
<hr />
<p>Isso é tudo para esse objetivo 🙂</p>
<p>Obrigado pela leitura e fique de olho no próximo post, que será o último objetivo sobre Web API: <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-5-consume-web-api-web-services/">Consume Web API web services</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-4-host-and-manage-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.4 – Host and manage a Web API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-509" class="post-509 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.3 – Secure a Web API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.3 – Secure a Web API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/" rel="bookmark"><time class="entry-date published" datetime="2016-03-01T16:07:53+00:00">01/03/2016</time><time class="updated" datetime="2016-03-02T11:45:22+00:00">02/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/#respond"><span class="dsq-postid" data-dsqidentifier="509 https://edneypitta.github.io/old-blog/?p=509">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
O objetivo 4.3 da certificação 70-487, <strong>Secure a Web API</strong>, trata de forma bem completa sobre as diferentes formas de segurança e autenticação disponíveis para serviços Web API.</p>
<p>Esse objetivo cobre como 1) autenticar e autorizar usuários, 2) implementar a autenticação HTTP Basic com SSL, 3) implementar Windows Authentication, 4) prevenir <em>cross-site request forgery</em>, 5) habilitar requests cross domain e 6) implementar e extender authorization filters.</p>
<h2>Autenticar E Autorizar Usuários</h2>
<p>Essa seção apenas explica os conceitos de autenticação e autorização.</p>
<p><strong>Autenticação </strong>é o processo de identificação do usuário, geralmente por um nome de usuário e senha. O framework da Web API tem uma série de ferramentas para implementação desse processo, o que vamos ver logo mais.</p>
<p><strong>Autorização </strong>é o processo que define quais ações o usuário pode fazer no sistema. Por exemplo, você pode permitir que usuários anônimos façam apenas consultas, usuários autenticados façam inserções e usuários administrativos façam atualizações.</p>
<h2>Implementando Autenticação HTTP Basic</h2>
<p>HTTP Basic é a forma mais simples e fácil de implementar um mecanismo de autenticação. É um formato conhecido e maduro, suportado pela maioria dos browsers e nativamente suportado pelo IIS. A principal desvantagem é que as credenciais são transmitidas em plain text nos headers do request, tornando-se vulnerável a interceptores. Também não há como fazer logout explicitamente a não ser que a sessão do browser se encerre.</p>
<p>O fluxo com HTTP Basic é assim:</p>
<p>Um client faz um request. Se o serviço necessitar autenticação, o server retorna o status code 401 (unauthorized) com o seguinte header: <code>WWW-Authenticate: Basic realm="Realm Name"</code>. Esse header especifica que o server suporta a autenticação Basic no domínio especificado (<em>realm</em>).</p>
<p>O client, ao receber um response 401, faz outro request com o header de autenticação. A construção do header começa com o nome de usuário e a senha concatenados por um dois-pontos. Por exemplo, caso o nome de usuário seja <em>JohnQPublic </em>e a senha <em>!*MyPa55w0rd*!</em>, o valor seria <em>JohnQPublic:!*MyPa55w0rd*!</em>. Em seguida esse valor seria encodado por Base64, resultando na string <em>Sm9oblFQdWJsaWM6ISpNeVBhNTV3MHJkKiE=</em>. Por fim, a palavra Basic é adicionada antes dessa string e enviada no header Authorization: <code>Authorization: Basic Sm9oblFQdWJsaWM6ISpNeVBhNTV3MHJkKiE=</code>.</p>
<p>Um ponto importante é que o nome de usuário e senha, apesar de encodados em Base64, não estão encriptados. Qualquer interceptor que tiver acesso aos headers do request vai conseguir decifrar dados sensíveis do usuário facilmente. Por isso, a autenticação Basic não é segura <strong>a não ser</strong> que feita por HTTPS, onde todo o request é criptografado. Para o exame (e para a vida real), lembre-se: nunca use autenticação Basic sem SSL.</p>
<h4>Habilitando SSL</h4>
<p>Como a autenticação Basic não deve ser utilizada sem SSL, você deve saber como forçar uma conexão HTTPS para Web API.</p>
<p>Se você viu como implementar Action Filters no <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" target="_blank">objetivo anterior</a>, vai reconhecer como vamos fazer isso agora. De forma simples, basta implementar a classe <em>AuthorizationFilterAttribute </em>e sobrescrever o método OnAuthorization com uma validação. Segue um exemplo:</p>
<p><script src="https://gist.github.com/edneypitta/1e6f53f48e88c814de52.js"></script></p>
<p>Depois disso, você deve decorar os controllers desejados com esse atributo ou registrá-lo globalmente no HttpConfiguration.</p>
<p>Não sei se cairá no exame, mas saiba que há uma ferramenta chamada <em>MakeCert.exe</em> para gerar certificados SSL para testes.</p>
<h2>Implementando Windows Authentication</h2>
<p>Windows Authentication é um processo onde os usuários podem se autenticar pelo seu login no Windows, Kerberos ou NTLM. É ideal para aplicações intranet que serão acessadas somente de dentro do mesmo domínio, em uma empresa por exemplo. Obviamente, não é recomendada para cenários onde usuários &#8220;anônimos&#8221; vão acessar sua API.</p>
<p>Por ser nativamente suportada pelo IIS, implementar essa autenticação é bem simples. Basta configurar a propriedade Mode do elemento Authentication para &#8220;Windows&#8221; no web.config, como a seguir:</p>
<p><code>&lt;system.web&gt;<br />
&lt;authentication mode=&quot;Windows&quot; /&gt;<br />
&lt;/system.web&gt;</code></p>
<p>Se o client for diretamente um browser, este precisa dar suporte ao esquema de autenticação Negotiation. Não há muito o que se preocupar pois todos os browsers populares têm esse suporte.<br />
Caso seja uma aplicação .NET, a classe HttpClient deve ser usada para fazer o request (como sempre). A única modificação é que ela deve ser instanciada com um HttpClientHandler, que pode ser obtido da seguinte maneira:</p>
<p><code>HttpClientHandler clientHandler = new HttpClientHandler<br />
{<br />
UseDefaultCredentials = true<br />
};</code></p>
<h2>Prevenindo Cross-Site Request Forgery</h2>
<p>Cross-Site Request Forgery (CSRF ou XSRF) é uma forma bastante utilizada por atacantes para acessarem recursos disponíveis para usuários autenticados.</p>
<p>Vamos supor que você está logado no portal do Azure e, no mesmo browser, recebe um e-mail dizendo que você tem desconto de 50% para novos serviços no Azure. Ao clicar no link do e-mail, você é direcionado para a página <em>https://manage.windowsazure.com/api/DeleteAllData</em> sem perceber. É claro que essa página não existe no portal, mas se existisse, você estaria em sérios problemas. </p>
<p>Resumidamente, um ataque XSRF acontece quando você está autenticado em algum sistema e um atacante se aproveita disso para executar alguma ação. Seu sistema está vulnerável a ataques XSFR se você usa um mecanismo de autenticação que mantém o usuário logado (baseado em cookies) ou quando você permite requests cross domain. A autenticação Basic também é vulnerável pois o browser normalmente armazena seu token de autenticação para evitar que o usuário digite o usuário e senha a cada request.</p>
<p>Para se proteger de ataques XSRF, há uma solução pronta em MVC e que os mesmos princípios podem ser aplicados na Web API.</p>
<p>Usando o método <em>Html.AntiForgeryToken</em> na view e o atributo <em>ValidateAntiForgeryToken</em> na action, o MVC primeiro renderiza um input hidden na tela assim: <code>&lt;input name="__RequestVerificationToken" type="hidden" value="saTFWpkKN0BYazFtN6c4YbZAmsEwG0srqlUqqloi/fVgeV2ciIFVmelvzwRZpArs" /&gt;</code>. Esse valor é gerado randomicamente e também é colocado num cookie passado para o usuário. Ao fazer um post, por exemplo, o MVC valida se o valor do cookie e o do form data são iguais. Isso é seguro pois o atacante não vai saber o valor do cookie para forjar um request válido.</p>
<p>Para Web API, como dito, o princípio pode ser aplicado. Você manda um valor no cookie e no HTML e depois garante que eles são o mesmo. Você pode mandar o token antiforgery usando o mesmo método Html.AntiForgeryToken.</p>
<p>Para validar o token na Web API, você deve obter o token do cookie; obter do form data; passar ambos para o método <em>AntiForgery.Validate</em> e retornar um response Unauthorized caso a validação falhe. O código ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/6ee611685a6f6a39ee4b.js"></script></p>
<h2>Habilitando Requests Cross Domain</h2>
<p>Por padrão, os browsers proíbem requests <em>cross domain</em>, ou seja, para domínios diferentes do atual. Por exemplo, se você está no site <em>http://www.contoso.com</em>, você não pode fazer uma requisição AJAX para <em>http://www.someotherwebsite.com</em>. Você também não pode fazer requests para o seu domínio com outro protocolo (HTTP ao invés de HTTPS) ou para outra porta. Isso existe para evitar ataques XSRF, já que a maioria das autenticações funcionam por cookie.</p>
<p>Porém você pode querer que sua API seja consumida por vários clients, e isso se tornaria um problema. Isso se chama CORS (cross origin resource sharing), e você pode habilitá-lo facilmente no arquivo web.config:</p>
<p><script src="https://gist.github.com/edneypitta/cd56a4873a71d13ba5e3.js"></script></p>
<p>Isso adiciona um header nos responses, indicando que CORS está habilitado. Com isso, <strong>qualquer </strong>site pode fazer requisições para sua API, o que pode não ser desejado.</p>
<p>Para resolver esse problema, a Microsoft criou um pacote NuGet chamado <em>Microsoft.AspNet.WebApi.Cors</em>. Após a instalação, você tem um método de extensão no objeto HttpConfiguration: <code>config.EnableCors();</code>. </p>
<p>Chamando esse método no método WebApiConfig.Register, você habilita o suporte a CORS na sua aplicação. Agora você pode adicionar o atributo <em>EnableCors</em> para controllers e actions assim:</p>
<p><script src="https://gist.github.com/edneypitta/1b09fb9b1119cb50c397.js"></script></p>
<p>Nesse caso, você habilitou CORS somente para esse método na URL especificada em <em>origins</em>.</p>
<h2>Implementando E Extendendo Authorization Filters</h2>
<p>A Web API oferece o atributo <em>AuthorizeAttribute</em> que por padrão garante que os usuários acessando esse controller ou action estão autenticados e têm as roles necessárias, se especificadas.</p>
<p>Você pode estender a classe AuthorizeAttribute e sobrescrever o método IsAuthorized para implementar sua própria lógica. O exemplo a seguir faz uma implementação de black list, ou seja, usuários com as roles especificadas <strong>não </strong>podem acessar a action:</p>
<p><script src="https://gist.github.com/edneypitta/79f6d70a5d1f4487fcd6.js"></script></p>
<p>Você também pode estender a classe <em>AuthorizationFilterAttribute</em> ou implementar a interface <em>IAuthorizationFilter</em> para realizar alguma lógica customizada. As diferenças entre elas são as seguintes:</p>
<ul>
<li><strong>AuthorizeAttribute</strong>: usada para implementar lógica de autorização baseada no usuário e nas roles;</li>
<li><strong>AuthorizationFilterAttribute</strong>: usada para implementar lógica síncrona de autorização que não está baseada no usuário e nas roles (por exemplo, forçar HTTPS);</li>
<li><strong>IAuthorizationFilter</strong>: usada para implementar lógica assíncrona de autorização que não está baseada no usuário e nas roles.</li>
</ul>
<hr />
<p>Obrigado pela leitura de mais um objetivo!<br />
O próximo post será sobre o objetivo 4.4, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-4-host-and-manage-a-web-api/">Host and manage a Web API</a></strong>.</p>
<p>Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.3 – Secure a Web API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-494" class="post-494 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.2 – Implement a Web API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.2 – Implement a Web API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" rel="bookmark"><time class="entry-date published" datetime="2016-02-29T15:38:47+00:00">29/02/2016</time><time class="updated" datetime="2016-03-01T16:58:35+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/#respond"><span class="dsq-postid" data-dsqidentifier="494 https://edneypitta.github.io/old-blog/?p=494">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>O objetivo 4.2, <strong>Implement a Web API</strong>, é a continuação lógica do objetivo anterior com alguns tópicos mais avançados como content negotiation, HttpMessageHandler, injeção de dependência, Action Filters, streaming, etc. Vamos lá?</p>
<h2>Manipulando Dados Em JSON</h2>
<p>Com sua Web API retornando os dados, é interessante (e óbvio) que você construa uma interface para seus usuários trabalharem com os dados. </p>
<p>Ao criar uma aplicação Web API, a engine de views Razor é usada por padrão e uma view Index.cshtml é criada na pasta Views/Home, com algum layout pronto. Fazendo as alterações a seguir no HTML, a tela fica mais ou menos assim:</p>
<p><script src="https://gist.github.com/edneypitta/8987912da3708fa19975.js"></script></p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/111.png" alt="index.cshtml" width="450" height="469" class="alignnone size-full wp-image-496" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/111.png 450w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/111-288x300.png 288w" sizes="(max-width: 450px) 100vw, 450px" /></p>
<p>O plano é listar todos os Customers na ul <em>customers</em> e os que contêm o Last Name informado pelo usuário na ul <em>results</em>. Tudo isso será feito via AJAX (Asynchronous JavaScript and XML), onde o browser consegue fazer requisições ao serviço Web API sem a necessidade de carregar a página inteira novamente.</p>
<p>O seguinte script pode ser utilizado:</p>
<p><script src="https://gist.github.com/edneypitta/f6f362bdc9a8d2671102.js"></script></p>
<p>O ponto principal dessa seção é que você não precisa alterar nada no serviço Web API para que ele aceite formatos em JSON ou XML. O passo mais importante no client é apenas indicar explicitamente se ele está enviando JSON ou XML pelo request header Content-Type (o método do jQuery getJSON() fez isso).</p>
<h2>Content Negotiation</h2>
<p>Content Negotiation (<em>negociação de conteúdo</em>) é o processo onde o client indica o tipo do retorno que ele deseja ao fazer uma chamada a um serviço Web API.<br />
Isso é feito por 4 headers no request:</p>
<ul>
<li><strong>Accept</strong>:  especifica o tipo do retorno do response. Para JSON o valor é <em>application/json</em> e para XML é <em>application/xml</em> ou <em>text/xml</em>;</li>
<li><strong>Accept-Charset</strong>: especifica o charset. Valores comuns são <em>UTF-8</em> e <em>ISO-8859-1</em>;</li>
<li><strong>Accept-Encoding</strong>: indica quais encodings são aceitos;</li>
<li><strong>Accept-Language</strong>: especifica a linguagem preferida.</li>
</ul>
<p>Para entender melhor, vamos olhar o request e o response da chamada ao serviço FindCustomers do exemplo anterior:</p>
<h5>Request</h5>
<p><code>GET http://localhost:53366/data/Customer/FindCustomers?lastName=r HTTP/1.1<br />
X-Requested-With: XMLHttpRequest<br />
<strong>Accept: application/json, text/javascript, */*; q=0.01</strong><br />
Referer: http://localhost:53366/<br />
<strong>Accept-Language: en-US,en;q=0.5</strong><br />
<strong>Accept-Encoding: gzip, deflate</strong><br />
User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)<br />
Host: localhost:53366<br />
DNT: 1<br />
Connection: Keep-Alive</code></p>
<h5>Response</h5>
<p><code>HTTP/1.1 200 OK<br />
Cache-Control: no-cache<br />
Pragma: no-cache<br />
<strong>Content-Type: application/json; charset=utf-8</strong><br />
Expires: -1<br />
Server: Microsoft-IIS/8.0<br />
X-AspNet-Version: 4.0.30319<br />
X-SourceFiles: =?UTF-8?B?QzpcUHJvamVjdHNcTXlTb2x1dGlvblxNeVdlYkFwaVxkYXRhXEN1c3RvbWVyXEZpbmRDdXN0b21lcnM=?=<br />
X-Powered-By: ASP.NET<br />
Date: Mon, 15 Jul 2013 15:52:20 GMT<br />
Content-Length: 290<br />
[{"CustomerId":4,"AccountId":2,"FirstName":"Captain","LastName":"America"},<br />
{"CustomerId":8,"AccountId":3,"FirstName":"Ham","LastName":"Burgler"},<br />
{"CustomerId":11,"AccountId":4,"FirstName":"Betty","LastName":"Rubble"},<br />
{"CustomerId":12,"AccountId":4,"FirstName":"Barney","LastName":"Rubble"}]</code></p>
<p>Nesse caso, o client fez a requisição solicitando o resultado em JSON (application/json), JavaScript (text/javascript) ou qualquer outra coisa (*/*). O servidor informou que o retorno está em JSON pelo response header Content-Type.</p>
<p>Caso alguma Exception acontecesse, o response estaria com o status code 500 mas o body ainda seria JSON, provavelmente com a Exception serializada.</p>
<p>A execução dessa negociação acontece da seguinte forma: quando o request é recebido pelo servidor, o framework obtém uma instância de <em>IContentNegotiator </em>do HttpConfiguration, que tem a lista dos formatters disponíveis. O método Negotiate de IContentNegotiator é chamado com 3 parâmetros (o tipo do objeto sendo serializado, a lista dos formatters e o request) e retorna o formatter a ser utilizado e o media type para o response. Se nenhum formatter for encontrado, o client recebe um response com o HttpStatusCode NotAcceptable (406).</p>
<h2>Data Binding</h2>
<p>Um dos aspectos importantes da Web API é o binding dos dados. As actions que você cria recebem parâmetros e é importante entender como o framework &#8220;preenche&#8221; os valores.</p>
<p>No caso de tipos simples como int, string, bool, DateTime, etc., os valores vêm da URL. No nosso exemplo anterior, o serviço FindCustomers recebe uma string lastName que é passada na URL como query string: <code>/data/Customer/FindCustomers?lastName=r</code>. Para tipo complexos (classes), o framework obtém os dados do body usando um formatter.</p>
<p>Você pode alterar o processo de binding padrão. O atributo <strong>FromUri</strong>, por exemplo, indica que um tipo complexo deve ser lido da URL ao invés do body:</p>
<p><code>public HttpResponseMessage Get([FromUri] Person person)</code></p>
<p>Dessa forma você chamaria esse serviço assim: <code>/api/Persons/?FirstName=John&LastName=Doe</code>. De maneira similar, o atributo <strong>FromBody</strong> indica que o tipo simples deve ser obtido do body.</p>
<h2>HttpMessageHandler</h2>
<p>Message handlers fazem parte do pipeline do framework Web API e são responsáveis por interceptar as mensagens que chegam (requests) e as que são retornadas (responses) para os clients.</p>
<p>Você pode implementar um message handler para efetuar alguma lógica ou fazer alguma validação antes que uma action seja chamada. Isso é possível derivando a classe <em>System.Net.Http.DelegatingHandler</em> e implementando o método SendAsync. Por exemplo:</p>
<p><script src="https://gist.github.com/edneypitta/4dcd04309149b894f6bb.js"></script></p>
<p>Para interromper o request, basta não chamar o método base e retornar um response de falha.</p>
<p>Seu handler precisa ainda ser registrado no pipeline da Web API. Você pode fazer isso de duas formas.</p>
<p>Na primeira, você adiciona o handler nos MessageHandlers do HttpConfiguration, no método Register da classe WebApiConfig: <code>config.MessageHandlers.Add(new LoggingMessageHandler());</code><br />
Dessa forma o handler é registrado globalmente, sendo executado para todos os requests.</p>
<p>O outro jeito é adicionar o handler para uma rota específica, fazendo ele ser executado apenas para actions daquela rota:</p>
<p><script src="https://gist.github.com/edneypitta/ad13f18a65756d5a2239.js"></script></p>
<h2>Implementando Injeção De Dependência</h2>
<p>Por motivos fora do escopo do exame, dependências <em>suck</em>. Tome o código a seguir como exemplo:</p>
<p><code>public string Get()<br />
{<br />
WebClient webClient = new WebClient();<br />
string result = webClient.DownloadString("http://microsoft.com");<br />
return result;<br />
}</code></p>
<p>Seria bem melhor você ter uma interface <em>IContentRepository</em> com um método <em>GetContent(string uri)</em> e ter uma implementação <em>WebClientContentRepository</em>, que utiliza a classe WebClient. O controller agora ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/e1b88d5ed2c0da9333af.js"></script></p>
<p>Com o código desacoplado, você precisa de um mecanismo para preencher a dependência do seu controller. A interface <em>IDependencyResolver </em> pode ser implementada da seguinte forma:</p>
<p><script src="https://gist.github.com/edneypitta/fe1ae6907af0f19cf9fc.js"></script></p>
<p>Configurando o DependencyResolver no objeto HttpConfiguration (<code>config.DependencyResolver = new ResolveController();</code>), o framework já consegue resolver a dependência de IContentRepository.</p>
<p>Essa obviamente não é a melhor opção, pois cada nova dependência vai acarretar numa mudança na verificação do tipo do controller no método GetService. Para resolver esse problema, existem vários projetos open source que ajudam nessa implementação, e talvez uma delas caia no exame: Unity.</p>
<p>Ao instalar o Unity pelo NuGet, o arquivo Bootstrapper.cs é adicionado ao projeto. As únicas coisas que você precisa saber é que o método BootStrapper.Initialize deve ser chamado no Global.asax e que você registra uma dependência dessa forma: <code>container.RegisterType<IContentRepository, WebClientContentRepository>();</code>.</p>
<h2>Action Filters E Exception Filters</h2>
<p>Filters são métodos que podem alterar a action que está sendo executada.<br />
Action Filter é um método que é invocado toda vez que uma action é chamada, enquanto Exception Filter é um método executado quando ocorre uma Exception não tratada.<br />
Para implementar uma Action Filter você implementa a classe <em>ActionFilterAttribute</em>, e para um Exception Filter a classe <em>ExceptionFilterAttribute</em>.</p>
<p>Veja o seguinte exemplo:</p>
<p><script src="https://gist.github.com/edneypitta/107242838bc2718f580a.js"></script></p>
<p>Esse filtro pode ser aplicado para forçar a action a retornar XML, sobrescrevendo o comportamento padrão.</p>
<p>Você pode aplicar esse atributo a um controller (que vai aplicar para todas as actions) ou actions específicas. Também é possível configurar esse filtro globalmente pela propriedade HttpConfiguration.Filters.</p>
<h2>Streaming Actions</h2>
<p>A classe <em>PushStreamContent</em> pode ser usada para uma action retornar um stream, quando você precisa enviar uma quantidade muito grande de dados para um client.</p>
<p>Segue um exemplo de implementação. Esse código usa um timer para enviar alguns dados para os clients conectados a cada segundo. A classe PushStreamContent é inicializada com o método OnStreamAvailable:</p>
<p><script src="https://gist.github.com/edneypitta/bbb02d6edd22ab2bdd8d.js"></script></p>
<p>Se você executar essa action, o request só vai terminar quando você fechar o browser. Dessa forma, você consegue enviar uma grande quantidade de dados em pacotes para o client.</p>
<hr />
<p>E chegamos ao final desse objetivo 🙂<br />
Obrigado pela leitura e fique de olho no post do próximo objetivo, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/">Secure a Web API</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.2 – Implement a Web API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-482" class="post-482 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.1 – Design a Web API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.1 – Design a Web API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" rel="bookmark"><time class="entry-date published" datetime="2016-02-26T10:16:29+00:00">26/02/2016</time><time class="updated" datetime="2016-03-01T16:58:30+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/#comments"><span class="dsq-postid" data-dsqidentifier="482 https://edneypitta.github.io/old-blog/?p=482">1 Comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!</p>
<p>Hoje vamos começar o primeiro objetivo do capítulo sobre Web API, <strong>Design a Web API</strong>. Esse objetivo cobre como escolher um método HTTP apropriado, definir recursos HTTP com actions, usar rotas, escolher formatos e planejar quando usar actions assíncronas. Vamos lá?</p>
<h2>Escolhendo Métodos HTTP</h2>
<p>Resumindo a introdução, Web API é um serviço REST (Representational State Transfer) baseado em HTTP. Ao invés de chamar um método específico, como no WCF, com Web API você faz uma chamada para uma URL em conjunto com um método HTTP.</p>
<p>Segue uma lista com os métodos HTTP existentes e depois entraremos em detalhes sobre os mais importantes:</p>
<ul>
<li><strong>Delete</strong>: deleta a entidade;</li>
<li><strong>Get</strong>: obtém os dados de uma ou mais entidades;</li>
<li><strong>Put</strong>: atualiza a entidade inteira;</li>
<li><strong>Patch</strong>: atualiza parcialmente a entidade;</li>
<li><strong>Post</strong>: cria uma nova entidade;</li>
<li><strong>Head</strong>: recupera somente os headers;</li>
<li><strong>Options</strong>: requisita informações sobre as opções disponíveis de comunicação.</li>
</ul>
<h4>HttpGet</h4>
<p>Geralmente o método mais usado, o HttpGet serve para obter dados de uma ou mais entidades. Ou seja, para cada entidade em um modelo, geralmente haverá um Get para obter todos os itens e outro Get para obter os detalhes de um item específico:</p>
<p><code>"/api/Foos" // obtém lista de todos os Foos<br />
"/api/Foos/keyvalue" // obtém um Foo com a key especificada<br />
"/api/Foos?attributename=attributevalue" // obtém um ou mais Foos com os atributos especificados</code></p>
<p>Caso nenhum valor seja encontrado, é importante lançar uma HttpResponseException com HttpStatusCode.NotFound (404) ao invés de simplesmente lançar uma Exception.</p>
<h4>HttpDelete</h4>
<p>Talvez o mais simples de todos, o HttpDelete simplesmente deleta uma entidade com o valor especificado, geralmente a chave. É aconselhável usar o prefixo <em>Delete</em> no nome do método do controller Web API.</p>
<p>Idealmente, há 3 possíveis retornos para um request Delete: </p>
<ul>
<li>HttpStatusCode.OK (200), que indica sucesso;</li>
<li>HttpStatusCode.Accepted (202), que indica que o request foi processado e aceito mas está ainda pendente;</</li>
<li>HttpStatusCode.NoResponse (204), valor padrão para métodos com retorno void</li>
</ul>
<h4>HttpPost</h4>
<p>Para criar uma nova entidade, o método HttpPost deve ser usado. Assim como em Delete, o prefixo <em>Post</em> deve ser utilizado.</p>
<p>Em caso de sucesso, o retorno estipulado pelo protocolo HTTP 1.1 é HttpStatusCode.Created (201), mas o status code padrão é 200 (OK). É também aconselhável retornar a localização (URL) de detalhes da nova entidade criada. Seguindo esses padrões, a implementação de um HttpPost para criar uma Account seria assim:</p>
<p><code>[HttpPost]<br />
public HttpResponseMessage PostAccount(Account account)<br />
{<br />
HttpResponseMessage response = Request.CreateResponse<Account>(HttpStatusCode.Created, account);<br />
string newUri = Url.Link("NamedApi", new { accountId = account.AccountId });<br />
response.Headers.Location = new Uri(newUri);<br />
return response;<br />
}</code></p>
<h4>HttpPut</h4>
<p>HttpPut deve ser utilizado para operações <em>upserts</em>, que inserem novos registros ou atualizam registros existentes. Também devem utilizar o prefixo <em>Put</em>.</p>
<p>Para atualizar uma Account, por exemplo, você deve receber um Id para procurar e uma Account para atualizar os valores. A implementação seria assim:</p>
<p><code>[HttpPut]<br />
public HttpResponseMessage PutAccount(int id, Account account)<br />
{<br />
// perform insert and/or edit here.<br />
}</code></p>
<h2>Definindo Recursos HTTP Com Actions</h2>
<p>Um serviço Web API nada mais é do que uma aplicação que usa controllers e actions para mapear URLs com ações HTTP. Esta seção foca no básico de como construir uma aplicação Web API.</p>
<h4>Criando O Model</h4>
<p>Voltando um pouco ao capítulo anterior, em WCF era necessário decorar suas classes com os atributos DataContract e DataMember para trafegá-las pelos serviços.</p>
<p>Com Web API, isso não é mais necessário. O próprio framework toma conta de enviar sua classe via HTTP, serializada em JSON ou XML. Isso evita o acoplamento entre seu modelo e o serviço que o expõe, além de facilitar os possíveis clients desse serviço pelo fato de JSON e XML serem praticamente universais.</p>
<p>Para os exemplos a seguir, vamos considerar o seguinte model:</p>
<p><script src="https://gist.github.com/edneypitta/167b3d7653d04b2112fb.js"></script></p>
<h4>Criando O Controller</h4>
<p>Os controllers são as classes que definem os serviços da sua Web API. Eles herdam de <em>ApiController</em> e cada método público vira uma <em>action</em>, como se fosse um método no WCF.</p>
<p>Veja a implementação dos controllers abaixo. Seguindo o padrão REST, é criado um serviço para cada tipo no modelo:</p>
<p><script src="https://gist.github.com/edneypitta/51124e2030818e670284.js"></script></p>
<p><script src="https://gist.github.com/edneypitta/4f8d4763dd6d01e8f0b4.js"></script></p>
<p>Com isso, você já tem sua Web API funcionando. Basta acessar <code>http://localhost:{porta}/api/Account</code> e a lista de Accounts é retornada. Chamando <code>/api/Account?accountId=1</code>, a Account com o Id 1 é retornada. </p>
<p>Um ponto importante é que, chamando essas URLs diretamente no browser, o comportamento é definido pelo próprio browser. O Chrome e o Firefox, por exemplo, mostrariam um XML na tela, enquanto o Internet Explorer faria o download de um JSON. Isso varia do request header <strong>Accept </strong>que o browser envia para a Web API.</p>
<h2>Definindo Rotas</h2>
<p>Toda a mágica da Web API de tornar métodos públicos em um controller acessíveis por clients acontece por causa da <em>Routing Table</em>. </p>
<p>Routing Table é um classe que implementa <em>System.Web.Http.Routing.IHttpRoute</em> e tem a tarefa de mepear um request para um controller e uma action específicos. No caso de Web API, a classe se chama WebApiConfig e fica dentro de App_Start:</p>
<p><script src="https://gist.github.com/edneypitta/bc41c4fabf2f6f1035d7.js"></script></p>
<p>Se você mudar o routeTemplate para <code>"data/{controller}/{id}"</code>, por exemplo, você agora acessa sua api com <code>http://localhost:{porta}/data/Account</code>.</p>
<p>Quando uma requisição é feita para uma Web API, o framework tenta achar o controller e a action segundo o que está definido na Routing Table. Se não encontra, uma HttpStatusCode 404 é retornado. Caso contrário, o request é encaminhado para o método. As seguintes ações são tomadas pelo framework para encontrar o controller e a action:</p>
<ul>
<li>Para achar o controller, a Web API adiciona a palavra <em>Controller</em> na variável do controller (por isso você chama diretamente Account, por exemplo);</li>
<li>Para a action, a Web API examina o método HTTP do request e tenta achar uma action com o nome correspondente;</li>
<li>Por padrão, isso só funciona com os métodos GET, POST, PUT e DELETE. Outro métodos são suportados, mas outro mecanismo é utilizado;</li>
<li>Por último, as variáveis no routeTemplate são mapeadas para os parâmetros da action (por padrão, <em>id</em>).</li>
</ul>
<p>Você pode setar explicitamente um método HTTP em uma action. Isso é importante quando você quer que o nome do método seja diferente do método HTTP. Para fazer isso, basta decorar o método com o atributo <em>System.Web.Http.ActionMethodSelectorAttribute</em>. Ele possui 4 valores: HttpGet, HttpPost, HttpDelete e HttpPut. O método ficaria assim: </p>
<p><code>[HttpGet]<br />
public Account GetAccount(int accountId)</code></p>
<p>Para definir múltiplos métodos HTTP para uma action ou suportar um método HTTP fora os 4 citados, você usa o atributo <em>System.Web.Http.AcceptVerbsAttribute</em>. O construtor aceita um array de strings que correspondem aos métodos que devem ser mapeados. O uso ficaria assim:</p>
<p><code>[System.Web.Http.AcceptVerbs("GET", "HEAD")]<br />
public IEnumerable<Customer> GetCustomers(int accountId)</code></p>
<h4>Alterando Actions</h4>
<p>Se você quiser criar as rotas com o nome da ation explícito, basta mudar a Routing Table para isso. O código ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/71116a14432f469431a7.js"></script></p>
<p>Com isso, ao invés de acessar <code>/api/Customer/1</code>, você acessa <code>/api/Customer/GetCustomers/1</code>. </p>
<p>Você pode alterar o nome da action pelo atributo <em>ActionNameAttribute</em>:</p>
<p><code>[HttpGet]<br />
[ActionName("FindCustomers")]<br />
public IEnumerable<Customer> SearchCustomers(string lastName)</code></p>
<p>Assim, você acessa essa action com a URL <code>/api/Customer/FindCustomers?lastName=r</code>.</p>
<p>O último ponto é que você pode querer que um método público no controller não seja uma action acessível pelo serviço. Para isso, decore o método com o atributo <em>NonAction</em>.</p>
<h2>Escolhendo Formatos</h2>
<p>O request header Accept indica o formato que o client espera como retorno. Acessando sua Web API pelo browser, geralmente o seguinte header é enviado: </p>
<p><code>Accept: text/html,application/xhtml+xml,application/xml</code></p>
<p>Por padrão, a Web API trabalha com JSON e XML. Isso é configurado por um objeto chamado <em>media-type formatter</em>.</p>
<p>Para essa seção, basta você saber isso e que você pode adicionar formatters customizados implementando a classe <em>MediaTypeFormatter </em>ou <em>BufferedMediaTypeFormatter</em>.</p>
<h2>Actions Assíncronas</h2>
<p>Ao fazer um request para um serviço Web API, uma thread é alocada do servidor para fazer o processamento necessário.<br />
Em cenários de grandes processamentos de I/O (entrada/saída), como acesso a banco de dados e chamadas a outros serviços, é importante liberar a thread atual para que ela processe mais requests enquanto essa entrada/saída longa é executada.</p>
<p>O C# 5 nos deu mecanismos para fazer isso de forma muito simples: as palavras-chave <em>async </em>e <em>await</em>. Tome por exemplo a seguinte action de uma Web API:</p>
<p><code>public string Get()<br />
{<br />
WebClient webClient = new WebClient();<br />
string result = webClient.DownloadString("http://microsoft.com");<br />
return result;<br />
}</code></p>
<p>Na maior parte do tempo, a thread alocada fica esperando o processamento I/O de fazer o request para o site da microsoft e buscar o HTML. Olhe essa action com async/await:</p>
<p><code>public <strong>async </strong>Task&lt;string&gt; Get()<br />
{<br />
WebClient webClient = new WebClient();<br />
string result = await webClient.DownloadString<strong>TaskAsync</strong>("http://microsoft.com");<br />
return result;<br />
}</code></p>
<p>Na chamada a <code>await webClient.DownloadStringTaskAsync</code>, a thread alocada é liberada para processar outros requests enquanto a requisição ao site da Microsoft é feita.</p>
<p>Um último alerta é que chamadas assíncronas devem ser feitas <strong>apenas</strong> para processamentos I/O. Se o método assíncrono fizer um processamento de CPU, outra thread terá que ser alocada para fazer esse processamento, o que invalida quaisquer benefícios da programação assíncrona (podendo até piorar devido à troca de threads).</p>
<hr />
<p>Chegamos ao fim desse objetivo 🙂</p>
<p>Obrigado pela leitura e espere pelo próximo post sobre o objetivo 4.2, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/">Implement a Web API</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.1 – Design a Web API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-474" class="post-474 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" title="Certificação Microsoft 70-487: Objetivo 3.9 – Host and manage services" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.9 – Host and manage services</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T22:51:45+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:23+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/#respond"><span class="dsq-postid" data-dsqidentifier="474 https://edneypitta.github.io/old-blog/?p=474">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá!<br />
Esse post será sobre o último objetivo do capítulo de WCF, Host and manage services.<br />
Esse objetivo cobre como gerenciar simultaneidade, escolher um Instance Mode, criar hosts, escolher um mecanismo de hosting, criar serviços transacionais e hostear em um Azure Worker Role.</p>
<h2>Gerenciando Simultaneidade</h2>
<p>É bem provável que seu serviço seja consumido por mais de um consumidor ao mesmo tempo. Com isso, é necessário tentar prever e gerenciar a simultaneidade que seu serviço suportará.</p>
<p>Dentro de ServiceBehavior, você pode definir o ConcurrencyMode: <code>[ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Single)]</code></p>
<p>O enum ConcurrencyMode possui 3 valores:</p>
<ul>
<li><strong>Single</strong>: em qualquer momento, somente 1 request tem acesso ao serviço WCF por vez. Caso vários requests sejam feitos simultaneamente, todos vão esperar até que o anterior complete seu processamento;</li>
<li><strong>Multiple</strong>: como o nome sugere, múltiplos requests podem ser feitos simultaneamente em threads separadas;</li>
<li><strong>Reentrant</strong>: funciona como o Single, mas se você fizer uma chamada a outro serviço, o lock é liberado para que o próximo request seja processado.</li>
</ul>
<h2>Escolhendo um Instance Mode</h2>
<p>Tratando ainda sobre simultaneidade, a configuração <strong>InstanceContextMode</strong> especifica o número de instâncias do serviço para processar os requests. Também tem 3 valores e, junto com ConcurrencyMode, dão 9 possíveis combinações.</p>
<p>Assim como ConcurrencyMode, você pode setar essa propriedade no atributo ServiceBehavior. Os 3 valores são:</p>
<ul>
<li><strong>Single</strong>: uma única instância do serviço é usada para todos os requests;</li>
<li><strong>PerSession</strong>: cria uma ou mais instâncias para cada client. É a configuração padrão;</li>
<li><strong>PerCall</strong>: cria uma ou mais instâncias para cada request.</li>
</ul>
<p>Esse é um assunto bem complexo e o comportamento de cada combinação aparentemente está fora do escopo do exame. Se quiser ir a fundo no tema, há um bom artigo no <a href="http://www.codeproject.com/Articles/89858/WCF-Concurrency-Single-Multiple-and-Reentrant-and" target="_blank">codeproject</a>.</p>
<h2>Criando Hosts</h2>
<p>Há várias opções de host para um serviço WCF. Vamos passar pelas opções disponíveis (ou prováveis de estar no exame) resumindo os pontos positivos e negativos.</p>
<h4>Self Hosting</h4>
<p>Serviços WCF podem ser hospedados em qualquer aplicação .NET. Você especifica a configuração do serviço em um arquivo de configuração ou no código em conjunto com instâncias da classe ServiceHost.</p>
<p>Há vários benefícios dessa forma. Como você pode facilmente trocar de hosts, se sua aplicação não estiver performando bem, você pode fazer upgrade para outro host ou habilitar outros bindings. Fazer debug da aplicação também fica facilitado.</p>
<p>A principal desvantagem é que você deve gerenciar todo o host, consertando quaisquer bugs que apareçam. Mover o host para outra máquina ou fazer um upgrade de hardware, se for necessário, também é doloroso. Por isso são geralmente usados para ambiente de desenvolvimento, e não produção.</p>
<h4>Managed Windows Services</h4>
<p>Não muito diferentes de outras aplicações .NET, Managed Services são parecidos com Self Hosting, mas com mais poder. Se a máquina reiniciar, por exemplo, o serviço pode startar automaticamente, sem a necessidade de um usuário logado. Também não é necessário usar IIS ou WAS para rodar na máquina.</p>
<p>Como desvantagens, você ainda precisa escrever código para criar o host com a classe ServiceHost e existe limitação para <em>scale up</em> e <em>scale down</em>. Services também tendem a ser mais difíceis para debug.</p>
<h4>Internet Information Services (IIS)</h4>
<p>O IIS, conhecido por hospedar aplicações ASP.NET, também pode ser usado para hospedar um serviço WCF.</p>
<p>As vantagens são todas as features que o IIS tem, como isolamento de pools de aplicações, recycling, desligamento por ociosidade, monitoramento, etc. Se o serviço precisar de alta disponibilidade e ser escalável, IIS é a escolha ideal.</p>
<p>A desvantagem que pode deixá-lo inutilizável para alguns serviços é que ele só suporta bindings que fazem o transporte por HTTP.</p>
<h4>Windows Activation Service (WAS)</h4>
<p>WAS, apesar de presente na maioria das grandes organizações, não é tão conhecido como o IIS. </p>
<p>Ele provê todos os benefícios do IIS e suporta outros tipos de transporte, como TCP, named pipes e MSMQ.</p>
<p>A desvantagem é que, por ser uma tecnologia nova, há pouco suporte e material sobre ela.</p>
<h4>Windows Azure</h4>
<p>Hospedar seu serviço na nuvem possui várias vantagens. A principal é que toda a dor de cabeça de manter um servidor com um serviço rodando fica com a Microsoft, e não com você.</p>
<p>Por enquanto, é suficiente saber que há 3 principais opções no Azure: WebRole, AppFabric service bus e WorkerRole.</p>
<p>A desvantagem pode ser que sua aplicação está hospedada por outras pessoas, o que tira o seu controle de ter um servidor on premise. Usando Azure, você ainda terá que fazer a escolhe entre self-host, IIS ou WAS.</p>
<h4>Classe ServiceHost</h4>
<p>Criar uma instância de ServiceHost é simples. Você chama o construtor passando o tipo do serviço, que deve estar referenciado. Há vários overloads do construtor, mas não são prováveis de estarem no exame. Após isso, você chama o método Open e por fim Close, ambos num try/catch pois várias coisas podem dar errado nesse tempo.</p>
<p><code>using (ServiceHost HostInstance = new ServiceHost(typeof(TestServiceType)))<br />
{<br />
 HostInstance.Open();<br />
 //Put in a Wait Condition so Host stays open<br />
 HostInstance.Close();<br />
}</code></p>
<p>Após o canal ser aberto por um client, o comportamento depende das definições do serviço (ConcurrencyMode, InstancingMode, tipos de endpoint, etc.). Um ponto importante para o client é que, caso haja algum erro não tratado, todo o canal é considerado falho e inválido para novas operações. Sempre deve haver a validação se a conexão está válida.</p>
<p>É importante também entender as opções de host. Como serviços WCF podem ser hospedados em qualquer AppDomain, seja uma aplicação Windows Form ou Console, se o AppDomain não estiver ativo, o host também não estará.</p>
<p>Ao usar um mecanismo de hosting como IIS ou WAS, não é necessário criar um ServiceHost. Basta configurar o serviço e gerenciar pela ferramenta.</p>
<p>Há outro ponto que possivelmente esteja no exame. Antes do .NET 4.0, se você quisesse usar o IIS para hospedar seu serviço, você tinha que criar uma aplicação ASP.NET com uma referência ao seu serviço, colocar as configurações no Web.config e criar um arquivo de texto com a extenção .svc (com uma única linha) para mapear o serviço. </p>
<p>Com a versão 4.0, isso não é mais necessário. Você pode usar a classe <strong>ServiceHostingEnvironment</strong>, que permite que você referencie o arquivo .svc virtualmente, sem a necessidade de criá-lo fisicamente. A configuração via arquivo fica assim:</p>
<p><code>&lt;serviceHostingEnvironment&gt;<br />
  &lt;serviceActivations&gt;<br />
    &lt;add relativeAddress=&quot;ServiceOrInterfaceName.svc&quot; service=&quot;FullyQualifiedServiceName&quot;/&gt;<br />
  &lt;/serviceActivations&gt;<br />
&lt;/serviceHostingEnvironment&gt;<br />
</code></p>
<h2>Escolhendo Um Mecanismo De Hosting</h2>
<p>Resumindo o que vimos até agora, você tem várias opções para hospedar um serviço WCF:</p>
<ul>
<li>Windows Form application</li>
<li>Console application</li>
<li>Managed Windows Service</li>
<li>ASP.NET application</li>
<li>IIS</li>
<li>WAS</li>
<li>Windows Azure</li>
</ul>
<p>Não existe regra para fazer essa escolha ou uma opção que atenda todos os cenários. Se seu serviço demandar que o transporte não seja feito por HTTP, por exemplo, o IIS não é uma opção. Ou se você precisar usar um binding MSMQ, você vai precisar de um host que dê suporte a isso.</p>
<p>Falando no geral, procure uma solução que te dê menos trabalho. IIS e WAS são produtos confiáveis, com uma base de usuários grande e fáceis de usar em conjunto com WCF. Escrever um novo host fatalmente irá gerar bugs ao longo do caminho.</p>
<h2>Criando Serviços Transacionais</h2>
<p>No <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-1-3-implement-transactions/" target="_blank">objetivo 1.3</a>, falamos sobre a classe TransactionScope. Ela também funciona de maneira bem simples com serviços WCF.</p>
<p>Você precisa decorar a operação com o atributo TransactionFlow (em conjunto com o atributo OperationContract), que especifica se a operação suporta transações. O construtor aceita 3 valores:</p>
<ul>
<li><code>[TransactionFlow(TransactionFlowOption.NotAllowed)]</code>: a operação não pode participar de uma transaction;</li>
<li><code>[TransactionFlow(TransactionFlowOption.Allowed)]</code>: a operação pode participar de uma transaction, se o client iniciar uma;</li>
<li><code>[TransactionFlow(TransactionFlowOption.Mandatory)]</code>: obrigatoriamente a chamada deve fazer parte de uma transaction.</li>
</ul>
<p>Além disso, você deve setar as propriedades TransactionAutoComplete e TransactionScopeRequired do OperationBehavior como true:</p>
<p><code>[OperationBehavior(TransactionAutoComplete = true, TransactionScopeRequired = true)]<br />
public String GetTestSummary(String examId){}</code></p>
<p>TransactionAutoComplete diz ao runtime para automaticamente completar a transação se nenhuma exceção for lançada. Caso seja, será feito o rollback. O atributo TransactionScopeRequired diz que o método precisa fazer parte de uma TransactionScope.</p>
<h2>Hospedando Serviços Em Um Azure WorkerRole</h2>
<p>Hospedar seu serviço no Azure em um WorkerRole significa ter mais controle sobre o servidor e as configurações do seu serviço, permitindo que você não use o IIS como hosting, por exemplo.</p>
<p>Com isso, é de sua responsabilidade configurar endpoints, inicializar e abrir um ServiceHost. Isso pode ser feito no método OnStart.</p>
<p>As configurações de endpoint podem estar no arquivo de configuração da role (.csdef). O código fica assim:</p>
<p><script src="https://gist.github.com/edneypitta/117c18d38759fa885679.js"></script></p>
<p>É interessante deixar a variável de host fora do método para que o garbage collector não a remova do escopo quando o método terminar.</p>
<p>O último detalhe desse objetivo, não relacionado a nenhum item, é que você deve saber que existe um <strong>DiscoveryEndpoint</strong> que faz com que seu serviço seja descoberto por clients.</p>
<hr />
<p>E acabamos o capítulo 3 sobre serviços WCF 😀 Por ser o maior objetivo da certificação, o assunto ficou bem extenso e chato, às vezes. </p>
<p>Mas agora vem o capítulo 4 com os objetivos sobre Web API, que é o mais comum nas aplicações hoje em dia (e bem mais elegante).</p>
<p>O próximo objetivo será o 4.1,<strong> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/">Design a Web API</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" title="Certificação Microsoft 70-487: Objetivo 3.9 – Host and manage services">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-469" class="post-469 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" title="Certificação Microsoft 70-487: Objetivo 3.8 – Implement messaging patterns" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.8 – Implement messaging patterns</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T15:25:10+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:18+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/#respond"><span class="dsq-postid" data-dsqidentifier="469 https://edneypitta.github.io/old-blog/?p=469">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
O objetivo 3.8, Implement messaging patterns, trata de <em>Message Exchange Patterns</em> (ou Padrões de Troca de Mensagem), que são mecanismos que descrevem como o client e o server vão se comunicar.<br />
Vamos cobrir como implementar os tipos one-way, request/reply, streaming e duplex, além de falar sobre alguns mecanismos no Azure. Vamos lá?</p>
<h2>Implementando One-Way, Request/Reply, Streaming e Duplex</h2>
<h4>One-Way</h4>
<p>Implementações one-way servem para cenários <em>fire and forget</em>, onde você faz uma chamada e não se importa com a resposta, como escrever alguma coisa em um log.</p>
<p>O WCF suporta implementações one-way de forma simples. Basta setar o parâmetro IsOneWay como true no atributo OperationContract e não ter nenhum tipo de retorno no método: </p>
<p><code>[OperationContract(IsOneWay = true)]<br />
void LogMessage(String message);</code></p>
<p>Num cenário comum, um request é feito para o servidor que processa e envia um response. Com OneWay, acontece o seguinte: quando o request é feito, o servidor responde instantaneamente com o StatusCode 202, Accepted. Só depois disso ele vai de fato processar o request, como se fosse uma operação assíncrona.</p>
<p>Apesar de ser uma boa feature, OneWay deve ser usado com cuidado. Operações críticas podem dar errado sem que você saiba, causando problemas. Bons candidatos a OneWay são operações de baixa prioridade e que não retornam valor.</p>
<h4>Streaming</h4>
<p>Ao implementar streaming com WCF, você tem dois modos para trabalhar: <strong>Buffered</strong> ou <strong>Streaming</strong>. </p>
<p>Buffered, o modo default, significa que a mensagem inteira precisa ser enviada para que o recebedor comece a leitura. Em Streaming, o recebedor consegue começar a leitura assim que a informação estiver disponível (cenário ideal para transferência de arquivos grandes, como áudio ou vídeo).</p>
<p>Nesse formato, uma propriedade importante é a maxReceivedMessageSize, que limita o tamanho de mensagens recebidas. Isso é crucial para evitar ataques DDoS.<br />
No nível do contrato, você começa o processo definindo o retorno de um método como Stream. Depois é necessário configurar o binding para que o TransferMode seja Streamed e aí configurar o atributo maxReceivedMessageSize. O arquivo de configuração ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/6b14037220816e6274db.js"></script></p>
<p>Há 4 valores para o enum TransferMode, com nomes bem sugestivos: <em>Buffered</em>, <em>Streamed</em>, <em>StreamedRequest </em>e <em>StreamedResponse</em>.</p>
<p>Um ponto para se ter em mente é que habilitar streaming para um serviço não vai automaticamente melhorar a performance. É verdade que com streaming não são necessários grandes buffers de memória, mas num contexto comum de transferência de informações a melhora de performance é imperceptível. </p>
<p>Outro aspecto é que nem todos os bindings suportam a propriedade TransferMode. Os únicos bindings padrão que aceitam são <em>BasicHttpBinding</em>, <em>NetTcpBinding </em>e <em>NetNamedPipeBinding</em>.</p>
<p>Por último, há algumas limitações ao se usar streaming. São elas:</p>
<ul>
<li>Operações que usam o transporte Streamed só podem ter um input e um output de parâmetro;</li>
<li>Headers SOAP são sempre buffered, mesmo habilitando streaming. Eles não podem ultrapassar o tamanho da propriedade MaxBufferSize;</li>
<li>As implementações de segurança Reliable Message e SOAP Message confiam na transmissão buffered. Geralmente você deve usar segurança no nível de transporte (<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/" target="_blank">objetivo 3.4</a>).</li>
</ul>
<h4>Request/Reply</h4>
<p>É o modo padrão de funcionamento de qualquer web service, onde o client envia um request, o server processa e envia um response. Não há muito a mais o que ser dito 😀 Vamos para o próximo item.</p>
<h4>Duplex</h4>
<p>Na comunicação duplex, o client se conecta com um serviço provendo um canal de comunicação, onde o server pode mandar mensagens de volta para o client. Para funcionar, tudo isso precisa existir no contexto de uma sessão.</p>
<p>Nesse cenário com WCF, além de definir um contrato de ServiceContract, outra interface é necessária para especificar a propriedade CallbackContract, que serve como callback. Para o exame, não é necessário saber mais que isso existe.</p>
<h2>Implementando Azure Service Bus E Azure Queues</h2>
<p>Como visto no <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" target="_blank">objetivo anterior</a>, o Azure Service Bus é um componente que conecta serviços WCF (e outras aplicações) pelo Azure.</p>
<p>Usando relay, a comunicação é feita diretamente entre as duas partes. Isso implica que ambas precisam estar online para a comunicação acontecer.<br />
Às vezes, você precisa de uma fila de comunicações ou usar um mecanismo de <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank">publish/subscribe</a>. O Azure também oferece essas tipos de comunicações.</p>
<p>Uma <em>Queue </em>(fila) permite que mensagens enviadas por um client sejam armazenadas até que outro client as leia. Um <em>Topic</em> extende o comportamento da queue adicionando <em>subscriptions</em>, onde cada client especifica critérios para filtrar as mensagens que vê. Como Topics não estarão no exame, vamos focar na Queue.</p>
<p>Quando usando uma Queue, você manda uma mensagem para o service bus com um conjunto de propriedades chave/valor e um body binário. A mensagem é armazenada pelo service bus e entregada a um recebedor em um determinado momento, desacoplando as duas (ou mais) aplicações. O recebedor pode remover o item da fila na leitura ou colocar um lock, processar a mensagem e depois removê-la (como o Storage Queue faz).</p>
<p>Questões sobre a implementação não são prováveis de estar no exame, então o conhecimento do mecanismo já é suficiente. Você pode obter mais detalhes <a href="https://azure.microsoft.com/en-us/documentation/articles/service-bus-dotnet-multi-tier-app-using-service-bus-queues/" target="_blank">aqui</a>.</p>
<p>O conceito importante é o uso da classe QueueClient que permite o envio e recebimento de mensagens da queue. A mensagem é representada pela classe BrokeredMessage.</p>
<p>E chegamos ao final desse objetivo.<br />
O próximo post, sobre o objetivo <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/">Host and manage services</a></strong>, será o último do capítulo sobre WCF.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" title="Certificação Microsoft 70-487: Objetivo 3.8 – Implement messaging patterns">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-461" class="post-461 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" title="Certificação Microsoft 70-487: Objetivo 3.7 – Create and configure a WCF service on Windows Azure" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.7 – Create and configure a WCF service on Windows Azure</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T11:37:02+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:10+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/#respond"><span class="dsq-postid" data-dsqidentifier="461 https://edneypitta.github.io/old-blog/?p=461">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>O objetivo Create and configure a WCF service on Windows Azure (finalmente sobre Azure) fala principalmente sobre o <strong>Azure Service Bus</strong>, serviço que permite que você exponha seu serviço WCF (ou qualquer outro) hospedado no seu próprio datacenter. Isso evita os problemas de instalação e configuração de deixar tudo <em>on premises</em> e te dá as vantagens que o Azure pode oferecer. Vamos lá?</p>
<h2>Criando E Configurando Bindings</h2>
<p>Apenas revisando, um serviço WCF basicamente precisa do ABC (address, binding e contract). Para fazer o deploy de um serviço WCF no Azure em uma Web Role ou Web Site você não precisa fazer nenhuma modificação no código ou nas configurações.</p>
<p>Usando a feature de <em>relay</em> do Azure Service Bus, você pode configurar alguns bindings adicionais no seu projeto adicionando o pacote NuGet <strong>Windows Azure Service Bus</strong>.</p>
<p>Considere o código a seguir, assumindo que ISecretService e SecretService formam o contrato e a implementação de um serviço:</p>
<p><script src="https://gist.github.com/edneypitta/a9a868a8cd8013f3551e.js"></script></p>
<p>Nesse exemplo, o serviço está exposto em dois endpoints, um interno (com NetTcpBinding) e um externo, usando a feature de relay do Azure Service Bus (com NetTcpRelayBinding). Ao fechar a aplicação (sh.Close()), o endpoint é removido do Azure.</p>
<p>Você pode configurar também o endpoint no Azure pelo arquivo de configuração:</p>
<p><script src="https://gist.github.com/edneypitta/37e5fbf9ad2587f2443b.js"></script></p>
<p>Nos dois exemplos o binding NetTcpRelayBinding é usado, mas há outros disponíveis.<br />
Tanto por código ou arquivo de configuração, você deve setar o nome do serviço e a Default Key.<br />
Outro ponto interessante é que o Azure Service Bus não requer nenhuma configuração no seu servidor on premise. Normalmente a comunicação é feita por TCP, mas se as portas não estiverem disponíveis, o relay pode usar as portas HTTP ou HTTPS.</p>
<h2>Criando Um Azure Service Bus</h2>
<p>Para criar um Azure Service Bus, basta ir no portal do Azure, selecionar a criação de um Azure Service Bus, configurar um namespace e selecionar uma região.</p>
<p>O portal vai informar a connection string de conexão, que contém o nome do serviço e a Default Key:</p>
<p><code><strong>Endpoint</strong>=sb://wcfonazure.servicebus.windows.net/;<strong>SharedSecretIssuer</strong>=owner;<strong>SharedSecretValue</strong>=D1Kmb83CCLrAtz4du9vb3xn99DaM2dH4jQqSec98if4=<br />
</code></p>
<h2>Integrando Com O Azure Service Bus Relay</h2>
<p>Após criar um novo service bus no Azure e hospedar um serviço WCF, você pode criar um client para se comunicar com seu serviço on premise pelo Azure.</p>
<p>É necessário ter o namespace especificado, o nome do serviço e a Default Key. O código a seguir mostra como o consumo pode ser feito via ChannelFactory:</p>
<p><script src="https://gist.github.com/edneypitta/02832ee8fc50835b373b.js"></script></p>
<p>O método CreateSharedSecretTokenProvider se autentica no service bus pelo owner e a key, mas há outros mecanismos de autenticação como SAML ou SimpleWebToken.</p>
<p>Isso é tudo 🙂<br />
O próximo post será sobre o objetivo 3.8, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/">Implement messaging patterns</a></strong>.</p>
<p>Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" title="Certificação Microsoft 70-487: Objetivo 3.7 – Create and configure a WCF service on Windows Azure">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-456" class="post-456 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" title="Certificação Microsoft 70-487: Objetivo 3.6 – Version a WCF service" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.6 – Version a WCF service</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T10:37:00+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:54+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/#comments"><span class="dsq-postid" data-dsqidentifier="456 https://edneypitta.github.io/old-blog/?p=456">1 Comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
Continuando a série sobre a certificação Microsoft 70-487, esse post será sobre o objetivo 3.6, Version a WCF service.<br />
Esse objetivo, que é bem curto, cobre os conceitos sobre como versionar diferentes tipos de contratos e informações de bindings.</p>
<p>Várias mudanças podem ocorrer no ciclo de vida de um serviço WCF: no contrato, no endereço (address), nos bindings, na implementação de algum método, etc. Essas mudançar podem ser classificadas em <em>breaking changes</em> ou <em>Nonbreaking changes</em>.</p>
<p>Há 2 tipos de versionamento: <em>strict </em>e <em>lax</em>.</p>
<p>O versionamento strict é quando você tem um ou mais clients que não toleram mudanças no serviço. Nesse caso, <strong>todas </strong>as mudanças precisam levar isso em conta e você nunca deve modificar algum comportamento; apenas adicionar em outras versões ou namespaces.</p>
<p>No versionamento lax, suportado pelo WCF e até web services .asmx, você pode fazer pequenas alterações sem quebrar o contrato existente. É possível, por exemplo, adicionar um novo membro fazendo com que os dados sejam somente ignorados por clients antigos.</p>
<p>Esse objetivo é bem conceitual e saber quando uma mudança vai quebrar ou não um serviço é suficiente para o exame. Mudanças no contrato são breaking changes; adições no DataContract podem ser ignoradas por clients antigos e não vão quebrar a funcionalidade.</p>
<p>E é <strong>só</strong> isso 🙂<br />
O próximo objetivo, também curto, será o <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/">Create and configure a WCF service on Windows Azure</a></strong>.</p>
<p>Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" title="Certificação Microsoft 70-487: Objetivo 3.6 – Version a WCF service">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-441" class="post-441 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" title="Certificação Microsoft 70-487: Objetivo 3.5 – Consume WCF services" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.5 – Consume WCF services</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T09:54:44+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:06+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/#respond"><span class="dsq-postid" data-dsqidentifier="441 https://edneypitta.github.io/old-blog/?p=441">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá!<br />
Hoje vamos falar sobre o objetivo 3.5 da certificação 70-487, <strong>Consume WCF services</strong>.<br />
Esse objetivo cobre como consumir um serviço WCF de 3 formas: gerando classes proxy com Svcutil.exe, gerando classes proxy adicionando uma referência ao serviço e consumindo via ChannelFactory. Vamos lá?</p>
<h2>Gerando Proxies Com Svcutil.exe</h2>
<p>É possível consumir serviços WCF gerando uma classe proxy e interagindo com ela como se fosse uma classe comum, deixando o framework fazer toda a comunicação por trás.</p>
<p>O Svcutil.exe, uma ferramenta chamada pela linha de comando, é uma das formas de gerar classes proxy de um serviço WCF. É possível fazer a geração baseado em serviços existentes ou metadata. </p>
<p>A ferramenta também permite que você exporte metadata de um serviço, valide código de um serviço, faça download dos metadatas de serviços existentes e gere código de serialização.</p>
<p>A melhor maneira de estudar para o exame é criar alguns serviços e gerar as proxies chamando o Svcutil.exe com opções diferentes, analisando o que a ferramenta de fato faz. A lista abaixo traz as opções importantes para o exame ao chamar a ferramenta pela linha de comando (atalhos estão entre parênteses):</p>
<ul>
<li><strong>/directory:&lt;directory&gt; (/d)</strong>: especifica o diretório em que os arquivos gerados serão colocados. Se não for especificado, o diretório atual será usado. Caso o diretório já tenha sido usado, o Svcutil.exe irá sobrescrever os arquivos;</li>
<li><strong>/mergeConfig</strong>: caso o diretório já tenha sido usado, ao invés de sobrescrever os arquivos, com essa opção o Svcutil.exe irá fazer o merge das configurações;</li>
<li><strong>/help (/?)</strong>: lista as opções disponíveis;</li>
<li><strong>/noLogo</strong>: tira as informações Logo (copyright e mensagem de banner);</li>
<li><strong>/svcutilConfig:&lt;configFile&gt;</strong>: coloca as configurações no arquivo especificado. O default é o App.config;</li>
<li><strong>/target:&lt;output type&gt; (/t)</strong>: instrui a ferramenta a criar um output específico. As opções são <em>code</em>, <em>metadata</em> e <em>xmlSerializer</em>;</li>
<li><strong>/async (/a)</strong>: cria todos os métodos das classes proxy com a versão normal e uma Async;</li>
<li><strong>/internal (/i)</strong>: cria todos os métodos das classes proxy como <em>internal</em>, e não <em>public</em>;</li>
<li><strong>/serializer (/ser)</strong>: gera os tipos com um serializer específico. As opções são <em>Auto</em>, <em>DataContractSerializer</em> e <em>XmlSerializer</em>;</li>
<li><strong>/out (/o)</strong>: especifica o nome do arquivo para o código gerado;</li>
<li><strong>/language (/l)</strong>: especifica uma linguagem para o código gerado. As opções são <em>c#</em>, <em>cs</em>, <em>csharp</em>, <em>vb</em>, <em>visualbasic</em>, <em>c++</em> e <em>cpp</em>.</li>
</ul>
<h2>Gerando Proxies Por Referência</h2>
<p>Uma feature do Visual Studio é a possibilidade de gerar classes proxy adicionando uma referência a um serviço.<br />
Basta clicar com o botão direito no seu projeto e ir em Add Service Reference. A seguinte tela é mostrada:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/21.png" alt="add service" width="574" height="466" class="alignnone size-full wp-image-446" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/21.png 574w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/21-300x244.png 300w" sizes="(max-width: 574px) 100vw, 574px" /></p>
<p>Você pode prover uma URL de um serviço (com metadata habilitado) ou clicar no botão Discover para encontrar services que estão na mesma solution. Após clicar em Go, os serviços são listados e você pode especificar um namespace, o que é recomendado.</p>
<p>Ao clicar em Advanced abaixo, a tela Service Reference Settings é aberta:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/31.png" alt="service reference settings" width="590" height="607" class="alignnone size-full wp-image-448" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/31.png 590w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/31-292x300.png 292w" sizes="(max-width: 590px) 100vw, 590px" /></p>
<p>No topo você pode especificar o modificador de acesso e se métodos async devem ser gerados, como as opções /internal e /async usando Svcutil.exe.<br />
A opção Always Generate Message Contracts faz o que o nome diz, gera classes para os contratos.</p>
<p>Na seção Data Type, você pode definir o tipo das coleções. Nada te impede de usar generics (List&lt;T&gt;), mas geralmente arrays são utilizados para manter a compatibilidade entre diferentes clients que não sejam .NET.</p>
<p>A última seção, Compatibility, serve se você estiver consumindo um web service antigo <em>.asmx</em>. A tela Add Web Reference é aberta:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/41.png" alt="add web reference" width="848" height="593" class="alignnone size-full wp-image-449" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/41.png 848w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/41-300x210.png 300w" sizes="(max-width: 848px) 100vw, 848px" /></p>
<h2>Criando E Implementando ChannelFactories</h2>
<p>A classe ChannelFactory serve para fazer comunicações com endpoints de forma simples. Ela pode atuar em conjunto com o arquivo de configuração da sua aplicação, fazendo com que uma chamada a um serviço tenha 2 linhas de código.</p>
<p>A primeira coisa que você deve saber é que a classe ChannelFactory trabalha com o contrato do serviço, então você deve ter uma referência à interface que especifica o contrato.</p>
<h4>Construtores</h4>
<p>O construtor padrão não aceita nenhum parâmetro, então informações sobre o endpoint precisam ser especificadas: <code>new ChannelFactory<ITestService>()</code>.</p>
<p>O próximo aceita uma string com o nome de configuração do endpoint:</p>
<p><code>String endpointConfigName = "wsHttp_BindingConfig";<br />
ChannelFactory&lt;ITestService&gt; proxy = new ChannelFactory&lt;ITestService&gt;(endpointConfigName);</code></p>
<p>Outro aceita um binding, mas funciona da mesma forma:</p>
<p><code>String endpointConfigName = "wsHttp_BindingConfig";<br />
WSHttpBinding wSBinding = new WSHttpBinding(EndpointConfigName);<br />
ChannelFactory&lt;ITestService&gt; proxy = new ChannelFactory&lt;ITestService&gt;(wSBinding);</code></p>
<p>O próximo aceita um ServiceEndpoint:</p>
<p><code>ServiceEndpoint endpoint = new ServiceEndpoint(new ContractDescription("Endpoint"));<br />
ChannelFactory&lt;ITestService&gt; proxy = new ChannelFactory&lt;ITestService&gt;(endpoint);</code></p>
<p>Há outros construtores que são bem intuitivos. Vamos a um cenário real de uso da classe ChannelFactory, algo bem provável de conter pelo menos 1 questão no exame:</p>
<p><script src="https://gist.github.com/edneypitta/d96af1c3b703d014e693.js"></script></p>
<p>O método CreateChannel inicializa a ChannelFactory, retornando o tipo do contrato especificado no construtor. Depois disso, basta chamar os métodos desejados que estão no contrato. Por fim, chame o método Close. Ele possui uma chamada padrão sem parâmetros e uma recebendo um TimeSpan, onde você indica que se o canal não for fechado nesse tempo uma exceção é lançada.</p>
<p>Por último, é importante destacar que com ChannelFactory você não precisa da classe de definição do serviço, apenas a interface do contrato.</p>
<p>Isso é tudo para esse objetivo 🙂<br />
Obrigado pela leitura e fique de olho no post do próximo objetivo, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/">Version a WCF service</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" title="Certificação Microsoft 70-487: Objetivo 3.5 – Consume WCF services">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				<nav class="navigation paging-navigation" role="navigation">
		<h1 class="screen-reader-text">Navegação de Posts</h1>
		<div class="nav-links">

						<div class="nav-previous"> <a href="https://edneypitta.github.io/old-blog/page/3/" ><i class="fa fa-chevron-left"></i> Anteriores</a></div>
			
						<div class="nav-next"><a href="https://edneypitta.github.io/old-blog/" >Próximos <i class="fa fa-chevron-right"></i></a> </div>
			
		</div><!-- .nav-links -->
	</nav><!-- .navigation -->
	
		
		</main><!-- #main -->
	</div><!-- #primary -->

</div>
	<div id="secondary" class="widget-area col-sm-12 col-md-4" role="complementary">
		<div class="well">
						<aside id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://edneypitta.github.io/old-blog/sobre/"><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/IMG-20150829-WA00012-e1440915174271-150x150.jpg"  width="150" height="150" class="aligncenter size-thumbnail wp-image-93" style="border-radius: 80px;" />
<h2 style="text-align:center;">Edney Pitta</h2></a>
<div style="text-align: center;">Desenvolvedor de Software @ Lambda3</div>
<div style="margin-top:20px;text-align:center;"><a href="https://edneypitta.github.io/old-blog/sobre/"><button class="btn btn-danger btn-lg " >SOBRE MIM</button></a></div></div>
		</aside><aside id="search-2" class="widget widget_search">
<form role="search" method="get" class="form-search" action="https://edneypitta.github.io/old-blog/">
  <div class="input-group">
  	<label class="screen-reader-text" for="s">Search for:</label>
    <input type="text" class="form-control search-query" placeholder="Procurar&hellip;" value="" name="s" title="Search for:" />
    <span class="input-group-btn">
      <button type="submit" class="btn btn-default" name="submit" id="searchsubmit" value="Search"><span class="glyphicon glyphicon-search"></span></button>
    </span>
  </div>
</form></aside>		<aside id="recent-posts-3" class="widget widget_recent_entries">		<h3 class="widget-title">Posts recentes</h3>		<ul>
					<li>
				<a href="https://edneypitta.github.io/old-blog/migrando-um-projeto-asp-net-core-rc-1-para-rc-2/">Migrando um projeto ASP.NET Core RC 1 para RC 2</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-486-developing-asp-net-mvc-web-applications/">Certificação Microsoft 70-486: Developing ASP.NET MVC Web Applications</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-480-programming-in-html5-with-javascript-and-css3/">Certificação Microsoft 70-480: Programming in HTML5 with JavaScript and CSS3</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-resultado/">Certificação Microsoft 70-487 &#8211; Resultado</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-5-6-share-assemblies-between-multiple-applications-and-servers/">Certificação Microsoft 70-487: Objetivo 5.6 – Share assemblies between multiple applications and servers</a>
						</li>
				</ul>
		</aside>		<aside id="annual_archive_widget-2" class="widget Annual_Archive_Widget"><h3 class="widget-title">Arquivo</h3>	<ul>
		<li><a href='https://edneypitta.github.io/old-blog/2016/06/'>junho 2016</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/05/'>maio 2016</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/04/'>abril 2016</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/03/'>março 2016</a>&nbsp;(10)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/02/'>fevereiro 2016</a>&nbsp;(11)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/01/'>janeiro 2016</a>&nbsp;(10)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/12/'>dezembro 2015</a>&nbsp;(3)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/11/'>novembro 2015</a>&nbsp;(3)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/10/'>outubro 2015</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/09/'>setembro 2015</a>&nbsp;(5)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/08/'>agosto 2015</a>&nbsp;(2)</li>
	</ul>
	</aside>		</div>
	</div><!-- #secondary -->
			</div><!-- close .*-inner (main-content or sidebar, depending if sidebar is used) -->
		</div><!-- close .row -->
	</div><!-- close .container -->
</div><!-- close .site-content -->

	<div id="footer-area">
		<div class="container footer-inner">
			<div class="row">
				
				</div>
		</div>

		<footer id="colophon" class="site-footer" role="contentinfo">
			<div class="site-info container">
				<div class="row">
										<nav role="navigation" class="col-md-6">
						<ul id="menu-social-1" class="nav footer-nav clearfix"><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-20"><a href="https://br.linkedin.com/in/edneypitta"><i class="fa fa-linkedin-square"></i></a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-22"><a href="https://www.facebook.com/edneypitta"><i class="fa fa-facebook-square"></i></a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-23"><a href="https://twitter.com/edneypitta"><i class="fa fa-twitter-square"></i></a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-24"><a href="https://edneypitta.github.io/old-blog/feed/"><i class="fa fa-rss"></i></a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-27"><a href="https://edneypitta.github.io/old-blog/sobre/"><i class="fa fa-info-circle"></i></a></li>
</ul>					</nav>
					<div class="copyright col-md-6">
						<a rel="license" href="http://creativecommons.org/licenses/by/2.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/2.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/2.0/">Creative Commons Attribution 2.0 Generic License</a>.						Theme by <a href="http://colorlib.com/" target="_blank">Colorlib</a> Powered by <a href="http://wordpress.org/" target="_blank">WordPress</a>					</div>
				</div>
			</div><!-- .site-info -->
			<div class="scroll-to-top"><i class="fa fa-angle-up"></i></div><!-- .scroll-to-top -->
		</footer><!-- #colophon -->
	</div>
</div><!-- #page -->

<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/skip-link-focus-fix.js?ver=20140222'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-includes/js/wp-embed.min.js?ver=4.8.2'></script>
<script type='text/javascript'>
/* <![CDATA[ */

/* ]]> */
</script>


</body>
</html>