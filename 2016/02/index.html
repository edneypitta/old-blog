<!doctype html>
	<!--[if !IE]>
	<html class="no-js non-ie" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if IE 7 ]>
	<html class="no-js ie7" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if IE 8 ]>
	<html class="no-js ie8" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if IE 9 ]>
	<html class="no-js ie9" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <![endif]-->
	<!--[if gt IE 9]><!-->
<html class="no-js" lang="pt-BR" prefix="og: http://ogp.me/ns#"> <!--<![endif]-->
<head>
<base href="https://edneypitta.github.io/old-blog" />

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">



<title>fevereiro 2016 - Edney Pitta</title>

<!-- This site is optimized with the Yoast SEO plugin v3.0.7 - https://yoast.com/wordpress/plugins/seo/ -->
<meta name="robots" content="noindex,follow"/>
<link rel="canonical" href="https://edneypitta.github.io/old-blog/2016/02/" />
<link rel="next" href="https://edneypitta.github.io/old-blog/2016/02/page/2/" />
<meta property="og:locale" content="pt_BR" />
<meta property="og:type" content="object" />
<meta property="og:title" content="fevereiro 2016 - Edney Pitta" />
<meta property="og:url" content="https://edneypitta.github.io/old-blog/2016/02/" />
<meta property="og:site_name" content="Edney Pitta" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="fevereiro 2016 - Edney Pitta"/>
<meta name="twitter:site" content="@edneypitta"/>
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='//fonts.googleapis.com' />
<link rel='dns-prefetch' href='//s.w.org' />


		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/2.3\/svg\/","svgExt":".svg","source":{"concatemoji":"http:\/\/edneypitta.github.io\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.8.2"}};
			!function(a,b,c){function d(a){var b,c,d,e,f=String.fromCharCode;if(!k||!k.fillText)return!1;switch(k.clearRect(0,0,j.width,j.height),k.textBaseline="top",k.font="600 32px Arial",a){case"flag":return k.fillText(f(55356,56826,55356,56819),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,56826,8203,55356,56819),0,0),c=j.toDataURL(),b!==c&&(k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447),0,0),b=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447),0,0),c=j.toDataURL(),b!==c);case"emoji4":return k.fillText(f(55358,56794,8205,9794,65039),0,0),d=j.toDataURL(),k.clearRect(0,0,j.width,j.height),k.fillText(f(55358,56794,8203,9794,65039),0,0),e=j.toDataURL(),d!==e}return!1}function e(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g,h,i,j=b.createElement("canvas"),k=j.getContext&&j.getContext("2d");for(i=Array("flag","emoji4"),c.supports={everything:!0,everythingExceptFlag:!0},h=0;h<i.length;h++)c.supports[i[h]]=d(i[h]),c.supports.everything=c.supports.everything&&c.supports[i[h]],"flag"!==i[h]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[i[h]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel='stylesheet' id='sparkling-bootstrap-css'  href='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/css/bootstrap.min.css?ver=4.8.2' type='text/css' media='all' />
<link rel='stylesheet' id='sparkling-icons-css'  href='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/css/font-awesome.min.css?ver=4.8.2' type='text/css' media='all' />
<link rel='stylesheet' id='sparkling-fonts-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A400italic%2C400%2C600%2C700%7CRoboto+Slab%3A400%2C300%2C700&#038;ver=4.8.2' type='text/css' media='all' />
<link rel='stylesheet' id='sparkling-style-css'  href='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/style.css?ver=4.8.2' type='text/css' media='all' />
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-includes/js/jquery/jquery.js?ver=1.12.4'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/modernizr.min.js?ver=4.8.2'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/bootstrap.min.js?ver=4.8.2'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/functions.min.js?ver=4.8.2'></script>
<link rel='https://api.w.org/' href='https://edneypitta.github.io/old-blog/wp-json/' />

 

<script data-cfasync="false" src="//load.sumome.com/" data-sumo-site-id="025f16b2b72012bef5c86b74ea4d0bd0652e8245a2df8c61ed302458c0f98f3b" async></script><style type="text/css">.entry-content {font-family: Open Sans; font-size:14px; font-weight: normal; color:#6B6B6B;}.navbar > .container .navbar-brand {
font-size: 35px;
margin-top: 7px;
}

#menu-social i{
font-size:17px;
}
#menu-social-1 i {
font-size:22px;
}

article ul {
    list-style: none;
    padding:0;
    margin:0;
margin-bottom: 10px;
}

article li { 
    padding-left: 1em; 
    text-indent: -.7em;
}

article li:before {
    content: "\2022";
    color: rgb(191, 66, 78); 
padding-right:7px;
font-size: 15px;
}

#logo {
margin: 10px 0px;
}

.textwidget a:hover h2{
color:#c9302c;
}</style>	<style type="text/css">
			.navbar > .container .navbar-brand {
			color: #ffffff;
		}
		</style>
	<link rel="icon" href="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-32x32.png" sizes="32x32" />
<link rel="icon" href="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-192x192.png" sizes="192x192" />
<link rel="apple-touch-icon-precomposed" href="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-180x180.png" />
<meta name="msapplication-TileImage" content="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-cropped-edneypitta-oficialissimo-fundo-branco-270x270.png" />

<script type="text/javascript">
jQuery(document).ready(function()
{
jQuery('.fa-linkedin-square').parent().attr('target', '_blank').attr('title', 'LinkedIn');
jQuery('.fa-facebook-square').parent().attr('target', '_blank').attr('title', 'Facebook');
jQuery('.fa-twitter-square').parent().attr('target', '_blank').attr('title', 'Twitter');
jQuery('.fa-rss').parent().attr('target', '_blank').attr('title', 'RSS');

jQuery('.fa-info-circle').parent().attr('title', 'Sobre');
});
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66613004-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<body class="archive date">
<div id="page" class="hfeed site">

	<header id="masthead" class="site-header" role="banner">
		<nav class="navbar navbar-default" role="navigation">
			<div class="container">
				<div class="row">
					<div class="site-navigation-inner col-sm-12">
						<div class="navbar-header">
							<button type="button" class="btn navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
								<span class="sr-only">Toggle navigation</span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
							</button>

							
							<div id="logo">
								<a href="https://edneypitta.github.io/old-blog/"><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/cropped-edneypitta-oficialissimo-fundo-branco.png"  height="84" width="411" alt="Edney Pitta"/></a>
							</div><!-- end of #logo -->

							
							
						</div>
						<div class="collapse navbar-collapse navbar-ex1-collapse"><ul id="menu-social" class="nav navbar-nav"><li id="menu-item-20" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-20"><a title="&lt;i class=&quot;fa fa-linkedin-square&quot;&gt;&lt;/i&gt;" href="https://br.linkedin.com/in/edneypitta"><i class="fa fa-linkedin-square"></i></a></li>
<li id="menu-item-22" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-22"><a title="&lt;i class=&quot;fa fa-facebook-square&quot;&gt;&lt;/i&gt;" href="https://www.facebook.com/edneypitta"><i class="fa fa-facebook-square"></i></a></li>
<li id="menu-item-23" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-23"><a title="&lt;i class=&quot;fa fa-twitter-square&quot;&gt;&lt;/i&gt;" href="https://twitter.com/edneypitta"><i class="fa fa-twitter-square"></i></a></li>
<li id="menu-item-24" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-24"><a title="&lt;i class=&quot;fa fa-rss&quot;&gt;&lt;/i&gt;" href="https://edneypitta.github.io/old-blog/feed/"><i class="fa fa-rss"></i></a></li>
<li id="menu-item-27" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-27"><a title="&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt;" href="https://edneypitta.github.io/old-blog/sobre/"><i class="fa fa-info-circle"></i></a></li>
</ul></div>					</div>
				</div>
			</div>
		</nav><!-- .site-navigation -->
	</header><!-- #masthead -->

	<div id="content" class="site-content">

		<div class="top-section">
								</div>

		<div class="container main-content-area">
			<div class="row">
				<div class="main-content-inner col-sm-12 col-md-8 pull-left">

	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">
					Mês: <span>fevereiro 2016</span>				</h1>
							</header><!-- .page-header -->

						
				
<article id="post-494" class="post-494 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.2 – Implement a Web API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.2 – Implement a Web API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" rel="bookmark"><time class="entry-date published" datetime="2016-02-29T15:38:47+00:00">29/02/2016</time><time class="updated" datetime="2016-03-01T16:58:35+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/#respond"><span class="dsq-postid" data-dsqidentifier="494 https://edneypitta.github.io/old-blog/?p=494">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>O objetivo 4.2, <strong>Implement a Web API</strong>, é a continuação lógica do objetivo anterior com alguns tópicos mais avançados como content negotiation, HttpMessageHandler, injeção de dependência, Action Filters, streaming, etc. Vamos lá?</p>
<h2>Manipulando Dados Em JSON</h2>
<p>Com sua Web API retornando os dados, é interessante (e óbvio) que você construa uma interface para seus usuários trabalharem com os dados. </p>
<p>Ao criar uma aplicação Web API, a engine de views Razor é usada por padrão e uma view Index.cshtml é criada na pasta Views/Home, com algum layout pronto. Fazendo as alterações a seguir no HTML, a tela fica mais ou menos assim:</p>
<p><script src="https://gist.github.com/edneypitta/8987912da3708fa19975.js"></script></p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/111.png" alt="index.cshtml" width="450" height="469" class="alignnone size-full wp-image-496" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/111.png 450w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/111-288x300.png 288w" sizes="(max-width: 450px) 100vw, 450px" /></p>
<p>O plano é listar todos os Customers na ul <em>customers</em> e os que contêm o Last Name informado pelo usuário na ul <em>results</em>. Tudo isso será feito via AJAX (Asynchronous JavaScript and XML), onde o browser consegue fazer requisições ao serviço Web API sem a necessidade de carregar a página inteira novamente.</p>
<p>O seguinte script pode ser utilizado:</p>
<p><script src="https://gist.github.com/edneypitta/f6f362bdc9a8d2671102.js"></script></p>
<p>O ponto principal dessa seção é que você não precisa alterar nada no serviço Web API para que ele aceite formatos em JSON ou XML. O passo mais importante no client é apenas indicar explicitamente se ele está enviando JSON ou XML pelo request header Content-Type (o método do jQuery getJSON() fez isso).</p>
<h2>Content Negotiation</h2>
<p>Content Negotiation (<em>negociação de conteúdo</em>) é o processo onde o client indica o tipo do retorno que ele deseja ao fazer uma chamada a um serviço Web API.<br />
Isso é feito por 4 headers no request:</p>
<ul>
<li><strong>Accept</strong>:  especifica o tipo do retorno do response. Para JSON o valor é <em>application/json</em> e para XML é <em>application/xml</em> ou <em>text/xml</em>;</li>
<li><strong>Accept-Charset</strong>: especifica o charset. Valores comuns são <em>UTF-8</em> e <em>ISO-8859-1</em>;</li>
<li><strong>Accept-Encoding</strong>: indica quais encodings são aceitos;</li>
<li><strong>Accept-Language</strong>: especifica a linguagem preferida.</li>
</ul>
<p>Para entender melhor, vamos olhar o request e o response da chamada ao serviço FindCustomers do exemplo anterior:</p>
<h5>Request</h5>
<p><code>GET http://localhost:53366/data/Customer/FindCustomers?lastName=r HTTP/1.1<br />
X-Requested-With: XMLHttpRequest<br />
<strong>Accept: application/json, text/javascript, */*; q=0.01</strong><br />
Referer: http://localhost:53366/<br />
<strong>Accept-Language: en-US,en;q=0.5</strong><br />
<strong>Accept-Encoding: gzip, deflate</strong><br />
User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)<br />
Host: localhost:53366<br />
DNT: 1<br />
Connection: Keep-Alive</code></p>
<h5>Response</h5>
<p><code>HTTP/1.1 200 OK<br />
Cache-Control: no-cache<br />
Pragma: no-cache<br />
<strong>Content-Type: application/json; charset=utf-8</strong><br />
Expires: -1<br />
Server: Microsoft-IIS/8.0<br />
X-AspNet-Version: 4.0.30319<br />
X-SourceFiles: =?UTF-8?B?QzpcUHJvamVjdHNcTXlTb2x1dGlvblxNeVdlYkFwaVxkYXRhXEN1c3RvbWVyXEZpbmRDdXN0b21lcnM=?=<br />
X-Powered-By: ASP.NET<br />
Date: Mon, 15 Jul 2013 15:52:20 GMT<br />
Content-Length: 290<br />
[{"CustomerId":4,"AccountId":2,"FirstName":"Captain","LastName":"America"},<br />
{"CustomerId":8,"AccountId":3,"FirstName":"Ham","LastName":"Burgler"},<br />
{"CustomerId":11,"AccountId":4,"FirstName":"Betty","LastName":"Rubble"},<br />
{"CustomerId":12,"AccountId":4,"FirstName":"Barney","LastName":"Rubble"}]</code></p>
<p>Nesse caso, o client fez a requisição solicitando o resultado em JSON (application/json), JavaScript (text/javascript) ou qualquer outra coisa (*/*). O servidor informou que o retorno está em JSON pelo response header Content-Type.</p>
<p>Caso alguma Exception acontecesse, o response estaria com o status code 500 mas o body ainda seria JSON, provavelmente com a Exception serializada.</p>
<p>A execução dessa negociação acontece da seguinte forma: quando o request é recebido pelo servidor, o framework obtém uma instância de <em>IContentNegotiator </em>do HttpConfiguration, que tem a lista dos formatters disponíveis. O método Negotiate de IContentNegotiator é chamado com 3 parâmetros (o tipo do objeto sendo serializado, a lista dos formatters e o request) e retorna o formatter a ser utilizado e o media type para o response. Se nenhum formatter for encontrado, o client recebe um response com o HttpStatusCode NotAcceptable (406).</p>
<h2>Data Binding</h2>
<p>Um dos aspectos importantes da Web API é o binding dos dados. As actions que você cria recebem parâmetros e é importante entender como o framework &#8220;preenche&#8221; os valores.</p>
<p>No caso de tipos simples como int, string, bool, DateTime, etc., os valores vêm da URL. No nosso exemplo anterior, o serviço FindCustomers recebe uma string lastName que é passada na URL como query string: <code>/data/Customer/FindCustomers?lastName=r</code>. Para tipo complexos (classes), o framework obtém os dados do body usando um formatter.</p>
<p>Você pode alterar o processo de binding padrão. O atributo <strong>FromUri</strong>, por exemplo, indica que um tipo complexo deve ser lido da URL ao invés do body:</p>
<p><code>public HttpResponseMessage Get([FromUri] Person person)</code></p>
<p>Dessa forma você chamaria esse serviço assim: <code>/api/Persons/?FirstName=John&LastName=Doe</code>. De maneira similar, o atributo <strong>FromBody</strong> indica que o tipo simples deve ser obtido do body.</p>
<h2>HttpMessageHandler</h2>
<p>Message handlers fazem parte do pipeline do framework Web API e são responsáveis por interceptar as mensagens que chegam (requests) e as que são retornadas (responses) para os clients.</p>
<p>Você pode implementar um message handler para efetuar alguma lógica ou fazer alguma validação antes que uma action seja chamada. Isso é possível derivando a classe <em>System.Net.Http.DelegatingHandler</em> e implementando o método SendAsync. Por exemplo:</p>
<p><script src="https://gist.github.com/edneypitta/4dcd04309149b894f6bb.js"></script></p>
<p>Para interromper o request, basta não chamar o método base e retornar um response de falha.</p>
<p>Seu handler precisa ainda ser registrado no pipeline da Web API. Você pode fazer isso de duas formas.</p>
<p>Na primeira, você adiciona o handler nos MessageHandlers do HttpConfiguration, no método Register da classe WebApiConfig: <code>config.MessageHandlers.Add(new LoggingMessageHandler());</code><br />
Dessa forma o handler é registrado globalmente, sendo executado para todos os requests.</p>
<p>O outro jeito é adicionar o handler para uma rota específica, fazendo ele ser executado apenas para actions daquela rota:</p>
<p><script src="https://gist.github.com/edneypitta/ad13f18a65756d5a2239.js"></script></p>
<h2>Implementando Injeção De Dependência</h2>
<p>Por motivos fora do escopo do exame, dependências <em>suck</em>. Tome o código a seguir como exemplo:</p>
<p><code>public string Get()<br />
{<br />
WebClient webClient = new WebClient();<br />
string result = webClient.DownloadString("http://microsoft.com");<br />
return result;<br />
}</code></p>
<p>Seria bem melhor você ter uma interface <em>IContentRepository</em> com um método <em>GetContent(string uri)</em> e ter uma implementação <em>WebClientContentRepository</em>, que utiliza a classe WebClient. O controller agora ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/e1b88d5ed2c0da9333af.js"></script></p>
<p>Com o código desacoplado, você precisa de um mecanismo para preencher a dependência do seu controller. A interface <em>IDependencyResolver </em> pode ser implementada da seguinte forma:</p>
<p><script src="https://gist.github.com/edneypitta/fe1ae6907af0f19cf9fc.js"></script></p>
<p>Configurando o DependencyResolver no objeto HttpConfiguration (<code>config.DependencyResolver = new ResolveController();</code>), o framework já consegue resolver a dependência de IContentRepository.</p>
<p>Essa obviamente não é a melhor opção, pois cada nova dependência vai acarretar numa mudança na verificação do tipo do controller no método GetService. Para resolver esse problema, existem vários projetos open source que ajudam nessa implementação, e talvez uma delas caia no exame: Unity.</p>
<p>Ao instalar o Unity pelo NuGet, o arquivo Bootstrapper.cs é adicionado ao projeto. As únicas coisas que você precisa saber é que o método BootStrapper.Initialize deve ser chamado no Global.asax e que você registra uma dependência dessa forma: <code>container.RegisterType<IContentRepository, WebClientContentRepository>();</code>.</p>
<h2>Action Filters E Exception Filters</h2>
<p>Filters são métodos que podem alterar a action que está sendo executada.<br />
Action Filter é um método que é invocado toda vez que uma action é chamada, enquanto Exception Filter é um método executado quando ocorre uma Exception não tratada.<br />
Para implementar uma Action Filter você implementa a classe <em>ActionFilterAttribute</em>, e para um Exception Filter a classe <em>ExceptionFilterAttribute</em>.</p>
<p>Veja o seguinte exemplo:</p>
<p><script src="https://gist.github.com/edneypitta/107242838bc2718f580a.js"></script></p>
<p>Esse filtro pode ser aplicado para forçar a action a retornar XML, sobrescrevendo o comportamento padrão.</p>
<p>Você pode aplicar esse atributo a um controller (que vai aplicar para todas as actions) ou actions específicas. Também é possível configurar esse filtro globalmente pela propriedade HttpConfiguration.Filters.</p>
<h2>Streaming Actions</h2>
<p>A classe <em>PushStreamContent</em> pode ser usada para uma action retornar um stream, quando você precisa enviar uma quantidade muito grande de dados para um client.</p>
<p>Segue um exemplo de implementação. Esse código usa um timer para enviar alguns dados para os clients conectados a cada segundo. A classe PushStreamContent é inicializada com o método OnStreamAvailable:</p>
<p><script src="https://gist.github.com/edneypitta/bbb02d6edd22ab2bdd8d.js"></script></p>
<p>Se você executar essa action, o request só vai terminar quando você fechar o browser. Dessa forma, você consegue enviar uma grande quantidade de dados em pacotes para o client.</p>
<hr />
<p>E chegamos ao final desse objetivo 🙂<br />
Obrigado pela leitura e fique de olho no post do próximo objetivo, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-3-secure-a-web-api/">Secure a Web API</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.2 – Implement a Web API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-482" class="post-482 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.1 – Design a Web API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 4.1 – Design a Web API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" rel="bookmark"><time class="entry-date published" datetime="2016-02-26T10:16:29+00:00">26/02/2016</time><time class="updated" datetime="2016-03-01T16:58:30+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/#comments"><span class="dsq-postid" data-dsqidentifier="482 https://edneypitta.github.io/old-blog/?p=482">1 Comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!</p>
<p>Hoje vamos começar o primeiro objetivo do capítulo sobre Web API, <strong>Design a Web API</strong>. Esse objetivo cobre como escolher um método HTTP apropriado, definir recursos HTTP com actions, usar rotas, escolher formatos e planejar quando usar actions assíncronas. Vamos lá?</p>
<h2>Escolhendo Métodos HTTP</h2>
<p>Resumindo a introdução, Web API é um serviço REST (Representational State Transfer) baseado em HTTP. Ao invés de chamar um método específico, como no WCF, com Web API você faz uma chamada para uma URL em conjunto com um método HTTP.</p>
<p>Segue uma lista com os métodos HTTP existentes e depois entraremos em detalhes sobre os mais importantes:</p>
<ul>
<li><strong>Delete</strong>: deleta a entidade;</li>
<li><strong>Get</strong>: obtém os dados de uma ou mais entidades;</li>
<li><strong>Put</strong>: atualiza a entidade inteira;</li>
<li><strong>Patch</strong>: atualiza parcialmente a entidade;</li>
<li><strong>Post</strong>: cria uma nova entidade;</li>
<li><strong>Head</strong>: recupera somente os headers;</li>
<li><strong>Options</strong>: requisita informações sobre as opções disponíveis de comunicação.</li>
</ul>
<h4>HttpGet</h4>
<p>Geralmente o método mais usado, o HttpGet serve para obter dados de uma ou mais entidades. Ou seja, para cada entidade em um modelo, geralmente haverá um Get para obter todos os itens e outro Get para obter os detalhes de um item específico:</p>
<p><code>"/api/Foos" // obtém lista de todos os Foos<br />
"/api/Foos/keyvalue" // obtém um Foo com a key especificada<br />
"/api/Foos?attributename=attributevalue" // obtém um ou mais Foos com os atributos especificados</code></p>
<p>Caso nenhum valor seja encontrado, é importante lançar uma HttpResponseException com HttpStatusCode.NotFound (404) ao invés de simplesmente lançar uma Exception.</p>
<h4>HttpDelete</h4>
<p>Talvez o mais simples de todos, o HttpDelete simplesmente deleta uma entidade com o valor especificado, geralmente a chave. É aconselhável usar o prefixo <em>Delete</em> no nome do método do controller Web API.</p>
<p>Idealmente, há 3 possíveis retornos para um request Delete: </p>
<ul>
<li>HttpStatusCode.OK (200), que indica sucesso;</li>
<li>HttpStatusCode.Accepted (202), que indica que o request foi processado e aceito mas está ainda pendente;</</li>
<li>HttpStatusCode.NoResponse (204), valor padrão para métodos com retorno void</li>
</ul>
<h4>HttpPost</h4>
<p>Para criar uma nova entidade, o método HttpPost deve ser usado. Assim como em Delete, o prefixo <em>Post</em> deve ser utilizado.</p>
<p>Em caso de sucesso, o retorno estipulado pelo protocolo HTTP 1.1 é HttpStatusCode.Created (201), mas o status code padrão é 200 (OK). É também aconselhável retornar a localização (URL) de detalhes da nova entidade criada. Seguindo esses padrões, a implementação de um HttpPost para criar uma Account seria assim:</p>
<p><code>[HttpPost]<br />
public HttpResponseMessage PostAccount(Account account)<br />
{<br />
HttpResponseMessage response = Request.CreateResponse<Account>(HttpStatusCode.Created, account);<br />
string newUri = Url.Link("NamedApi", new { accountId = account.AccountId });<br />
response.Headers.Location = new Uri(newUri);<br />
return response;<br />
}</code></p>
<h4>HttpPut</h4>
<p>HttpPut deve ser utilizado para operações <em>upserts</em>, que inserem novos registros ou atualizam registros existentes. Também devem utilizar o prefixo <em>Put</em>.</p>
<p>Para atualizar uma Account, por exemplo, você deve receber um Id para procurar e uma Account para atualizar os valores. A implementação seria assim:</p>
<p><code>[HttpPut]<br />
public HttpResponseMessage PutAccount(int id, Account account)<br />
{<br />
// perform insert and/or edit here.<br />
}</code></p>
<h2>Definindo Recursos HTTP Com Actions</h2>
<p>Um serviço Web API nada mais é do que uma aplicação que usa controllers e actions para mapear URLs com ações HTTP. Esta seção foca no básico de como construir uma aplicação Web API.</p>
<h4>Criando O Model</h4>
<p>Voltando um pouco ao capítulo anterior, em WCF era necessário decorar suas classes com os atributos DataContract e DataMember para trafegá-las pelos serviços.</p>
<p>Com Web API, isso não é mais necessário. O próprio framework toma conta de enviar sua classe via HTTP, serializada em JSON ou XML. Isso evita o acoplamento entre seu modelo e o serviço que o expõe, além de facilitar os possíveis clients desse serviço pelo fato de JSON e XML serem praticamente universais.</p>
<p>Para os exemplos a seguir, vamos considerar o seguinte model:</p>
<p><script src="https://gist.github.com/edneypitta/167b3d7653d04b2112fb.js"></script></p>
<h4>Criando O Controller</h4>
<p>Os controllers são as classes que definem os serviços da sua Web API. Eles herdam de <em>ApiController</em> e cada método público vira uma <em>action</em>, como se fosse um método no WCF.</p>
<p>Veja a implementação dos controllers abaixo. Seguindo o padrão REST, é criado um serviço para cada tipo no modelo:</p>
<p><script src="https://gist.github.com/edneypitta/51124e2030818e670284.js"></script></p>
<p><script src="https://gist.github.com/edneypitta/4f8d4763dd6d01e8f0b4.js"></script></p>
<p>Com isso, você já tem sua Web API funcionando. Basta acessar <code>http://localhost:{porta}/api/Account</code> e a lista de Accounts é retornada. Chamando <code>/api/Account?accountId=1</code>, a Account com o Id 1 é retornada. </p>
<p>Um ponto importante é que, chamando essas URLs diretamente no browser, o comportamento é definido pelo próprio browser. O Chrome e o Firefox, por exemplo, mostrariam um XML na tela, enquanto o Internet Explorer faria o download de um JSON. Isso varia do request header <strong>Accept </strong>que o browser envia para a Web API.</p>
<h2>Definindo Rotas</h2>
<p>Toda a mágica da Web API de tornar métodos públicos em um controller acessíveis por clients acontece por causa da <em>Routing Table</em>. </p>
<p>Routing Table é um classe que implementa <em>System.Web.Http.Routing.IHttpRoute</em> e tem a tarefa de mepear um request para um controller e uma action específicos. No caso de Web API, a classe se chama WebApiConfig e fica dentro de App_Start:</p>
<p><script src="https://gist.github.com/edneypitta/bc41c4fabf2f6f1035d7.js"></script></p>
<p>Se você mudar o routeTemplate para <code>"data/{controller}/{id}"</code>, por exemplo, você agora acessa sua api com <code>http://localhost:{porta}/data/Account</code>.</p>
<p>Quando uma requisição é feita para uma Web API, o framework tenta achar o controller e a action segundo o que está definido na Routing Table. Se não encontra, uma HttpStatusCode 404 é retornado. Caso contrário, o request é encaminhado para o método. As seguintes ações são tomadas pelo framework para encontrar o controller e a action:</p>
<ul>
<li>Para achar o controller, a Web API adiciona a palavra <em>Controller</em> na variável do controller (por isso você chama diretamente Account, por exemplo);</li>
<li>Para a action, a Web API examina o método HTTP do request e tenta achar uma action com o nome correspondente;</li>
<li>Por padrão, isso só funciona com os métodos GET, POST, PUT e DELETE. Outro métodos são suportados, mas outro mecanismo é utilizado;</li>
<li>Por último, as variáveis no routeTemplate são mapeadas para os parâmetros da action (por padrão, <em>id</em>).</li>
</ul>
<p>Você pode setar explicitamente um método HTTP em uma action. Isso é importante quando você quer que o nome do método seja diferente do método HTTP. Para fazer isso, basta decorar o método com o atributo <em>System.Web.Http.ActionMethodSelectorAttribute</em>. Ele possui 4 valores: HttpGet, HttpPost, HttpDelete e HttpPut. O método ficaria assim: </p>
<p><code>[HttpGet]<br />
public Account GetAccount(int accountId)</code></p>
<p>Para definir múltiplos métodos HTTP para uma action ou suportar um método HTTP fora os 4 citados, você usa o atributo <em>System.Web.Http.AcceptVerbsAttribute</em>. O construtor aceita um array de strings que correspondem aos métodos que devem ser mapeados. O uso ficaria assim:</p>
<p><code>[System.Web.Http.AcceptVerbs("GET", "HEAD")]<br />
public IEnumerable<Customer> GetCustomers(int accountId)</code></p>
<h4>Alterando Actions</h4>
<p>Se você quiser criar as rotas com o nome da ation explícito, basta mudar a Routing Table para isso. O código ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/71116a14432f469431a7.js"></script></p>
<p>Com isso, ao invés de acessar <code>/api/Customer/1</code>, você acessa <code>/api/Customer/GetCustomers/1</code>. </p>
<p>Você pode alterar o nome da action pelo atributo <em>ActionNameAttribute</em>:</p>
<p><code>[HttpGet]<br />
[ActionName("FindCustomers")]<br />
public IEnumerable<Customer> SearchCustomers(string lastName)</code></p>
<p>Assim, você acessa essa action com a URL <code>/api/Customer/FindCustomers?lastName=r</code>.</p>
<p>O último ponto é que você pode querer que um método público no controller não seja uma action acessível pelo serviço. Para isso, decore o método com o atributo <em>NonAction</em>.</p>
<h2>Escolhendo Formatos</h2>
<p>O request header Accept indica o formato que o client espera como retorno. Acessando sua Web API pelo browser, geralmente o seguinte header é enviado: </p>
<p><code>Accept: text/html,application/xhtml+xml,application/xml</code></p>
<p>Por padrão, a Web API trabalha com JSON e XML. Isso é configurado por um objeto chamado <em>media-type formatter</em>.</p>
<p>Para essa seção, basta você saber isso e que você pode adicionar formatters customizados implementando a classe <em>MediaTypeFormatter </em>ou <em>BufferedMediaTypeFormatter</em>.</p>
<h2>Actions Assíncronas</h2>
<p>Ao fazer um request para um serviço Web API, uma thread é alocada do servidor para fazer o processamento necessário.<br />
Em cenários de grandes processamentos de I/O (entrada/saída), como acesso a banco de dados e chamadas a outros serviços, é importante liberar a thread atual para que ela processe mais requests enquanto essa entrada/saída longa é executada.</p>
<p>O C# 5 nos deu mecanismos para fazer isso de forma muito simples: as palavras-chave <em>async </em>e <em>await</em>. Tome por exemplo a seguinte action de uma Web API:</p>
<p><code>public string Get()<br />
{<br />
WebClient webClient = new WebClient();<br />
string result = webClient.DownloadString("http://microsoft.com");<br />
return result;<br />
}</code></p>
<p>Na maior parte do tempo, a thread alocada fica esperando o processamento I/O de fazer o request para o site da microsoft e buscar o HTML. Olhe essa action com async/await:</p>
<p><code>public <strong>async </strong>Task&lt;string&gt; Get()<br />
{<br />
WebClient webClient = new WebClient();<br />
string result = await webClient.DownloadString<strong>TaskAsync</strong>("http://microsoft.com");<br />
return result;<br />
}</code></p>
<p>Na chamada a <code>await webClient.DownloadStringTaskAsync</code>, a thread alocada é liberada para processar outros requests enquanto a requisição ao site da Microsoft é feita.</p>
<p>Um último alerta é que chamadas assíncronas devem ser feitas <strong>apenas</strong> para processamentos I/O. Se o método assíncrono fizer um processamento de CPU, outra thread terá que ser alocada para fazer esse processamento, o que invalida quaisquer benefícios da programação assíncrona (podendo até piorar devido à troca de threads).</p>
<hr />
<p>Chegamos ao fim desse objetivo 🙂</p>
<p>Obrigado pela leitura e espere pelo próximo post sobre o objetivo 4.2, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-2-implement-a-web-api/">Implement a Web API</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/" title="Certificação Microsoft 70-487: Objetivo 4.1 – Design a Web API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-474" class="post-474 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" title="Certificação Microsoft 70-487: Objetivo 3.9 – Host and manage services" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.9 – Host and manage services</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T22:51:45+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:23+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/#respond"><span class="dsq-postid" data-dsqidentifier="474 https://edneypitta.github.io/old-blog/?p=474">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá!<br />
Esse post será sobre o último objetivo do capítulo de WCF, Host and manage services.<br />
Esse objetivo cobre como gerenciar simultaneidade, escolher um Instance Mode, criar hosts, escolher um mecanismo de hosting, criar serviços transacionais e hostear em um Azure Worker Role.</p>
<h2>Gerenciando Simultaneidade</h2>
<p>É bem provável que seu serviço seja consumido por mais de um consumidor ao mesmo tempo. Com isso, é necessário tentar prever e gerenciar a simultaneidade que seu serviço suportará.</p>
<p>Dentro de ServiceBehavior, você pode definir o ConcurrencyMode: <code>[ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Single)]</code></p>
<p>O enum ConcurrencyMode possui 3 valores:</p>
<ul>
<li><strong>Single</strong>: em qualquer momento, somente 1 request tem acesso ao serviço WCF por vez. Caso vários requests sejam feitos simultaneamente, todos vão esperar até que o anterior complete seu processamento;</li>
<li><strong>Multiple</strong>: como o nome sugere, múltiplos requests podem ser feitos simultaneamente em threads separadas;</li>
<li><strong>Reentrant</strong>: funciona como o Single, mas se você fizer uma chamada a outro serviço, o lock é liberado para que o próximo request seja processado.</li>
</ul>
<h2>Escolhendo um Instance Mode</h2>
<p>Tratando ainda sobre simultaneidade, a configuração <strong>InstanceContextMode</strong> especifica o número de instâncias do serviço para processar os requests. Também tem 3 valores e, junto com ConcurrencyMode, dão 9 possíveis combinações.</p>
<p>Assim como ConcurrencyMode, você pode setar essa propriedade no atributo ServiceBehavior. Os 3 valores são:</p>
<ul>
<li><strong>Single</strong>: uma única instância do serviço é usada para todos os requests;</li>
<li><strong>PerSession</strong>: cria uma ou mais instâncias para cada client. É a configuração padrão;</li>
<li><strong>PerCall</strong>: cria uma ou mais instâncias para cada request.</li>
</ul>
<p>Esse é um assunto bem complexo e o comportamento de cada combinação aparentemente está fora do escopo do exame. Se quiser ir a fundo no tema, há um bom artigo no <a href="http://www.codeproject.com/Articles/89858/WCF-Concurrency-Single-Multiple-and-Reentrant-and" target="_blank">codeproject</a>.</p>
<h2>Criando Hosts</h2>
<p>Há várias opções de host para um serviço WCF. Vamos passar pelas opções disponíveis (ou prováveis de estar no exame) resumindo os pontos positivos e negativos.</p>
<h4>Self Hosting</h4>
<p>Serviços WCF podem ser hospedados em qualquer aplicação .NET. Você especifica a configuração do serviço em um arquivo de configuração ou no código em conjunto com instâncias da classe ServiceHost.</p>
<p>Há vários benefícios dessa forma. Como você pode facilmente trocar de hosts, se sua aplicação não estiver performando bem, você pode fazer upgrade para outro host ou habilitar outros bindings. Fazer debug da aplicação também fica facilitado.</p>
<p>A principal desvantagem é que você deve gerenciar todo o host, consertando quaisquer bugs que apareçam. Mover o host para outra máquina ou fazer um upgrade de hardware, se for necessário, também é doloroso. Por isso são geralmente usados para ambiente de desenvolvimento, e não produção.</p>
<h4>Managed Windows Services</h4>
<p>Não muito diferentes de outras aplicações .NET, Managed Services são parecidos com Self Hosting, mas com mais poder. Se a máquina reiniciar, por exemplo, o serviço pode startar automaticamente, sem a necessidade de um usuário logado. Também não é necessário usar IIS ou WAS para rodar na máquina.</p>
<p>Como desvantagens, você ainda precisa escrever código para criar o host com a classe ServiceHost e existe limitação para <em>scale up</em> e <em>scale down</em>. Services também tendem a ser mais difíceis para debug.</p>
<h4>Internet Information Services (IIS)</h4>
<p>O IIS, conhecido por hospedar aplicações ASP.NET, também pode ser usado para hospedar um serviço WCF.</p>
<p>As vantagens são todas as features que o IIS tem, como isolamento de pools de aplicações, recycling, desligamento por ociosidade, monitoramento, etc. Se o serviço precisar de alta disponibilidade e ser escalável, IIS é a escolha ideal.</p>
<p>A desvantagem que pode deixá-lo inutilizável para alguns serviços é que ele só suporta bindings que fazem o transporte por HTTP.</p>
<h4>Windows Activation Service (WAS)</h4>
<p>WAS, apesar de presente na maioria das grandes organizações, não é tão conhecido como o IIS. </p>
<p>Ele provê todos os benefícios do IIS e suporta outros tipos de transporte, como TCP, named pipes e MSMQ.</p>
<p>A desvantagem é que, por ser uma tecnologia nova, há pouco suporte e material sobre ela.</p>
<h4>Windows Azure</h4>
<p>Hospedar seu serviço na nuvem possui várias vantagens. A principal é que toda a dor de cabeça de manter um servidor com um serviço rodando fica com a Microsoft, e não com você.</p>
<p>Por enquanto, é suficiente saber que há 3 principais opções no Azure: WebRole, AppFabric service bus e WorkerRole.</p>
<p>A desvantagem pode ser que sua aplicação está hospedada por outras pessoas, o que tira o seu controle de ter um servidor on premise. Usando Azure, você ainda terá que fazer a escolhe entre self-host, IIS ou WAS.</p>
<h4>Classe ServiceHost</h4>
<p>Criar uma instância de ServiceHost é simples. Você chama o construtor passando o tipo do serviço, que deve estar referenciado. Há vários overloads do construtor, mas não são prováveis de estarem no exame. Após isso, você chama o método Open e por fim Close, ambos num try/catch pois várias coisas podem dar errado nesse tempo.</p>
<p><code>using (ServiceHost HostInstance = new ServiceHost(typeof(TestServiceType)))<br />
{<br />
 HostInstance.Open();<br />
 //Put in a Wait Condition so Host stays open<br />
 HostInstance.Close();<br />
}</code></p>
<p>Após o canal ser aberto por um client, o comportamento depende das definições do serviço (ConcurrencyMode, InstancingMode, tipos de endpoint, etc.). Um ponto importante para o client é que, caso haja algum erro não tratado, todo o canal é considerado falho e inválido para novas operações. Sempre deve haver a validação se a conexão está válida.</p>
<p>É importante também entender as opções de host. Como serviços WCF podem ser hospedados em qualquer AppDomain, seja uma aplicação Windows Form ou Console, se o AppDomain não estiver ativo, o host também não estará.</p>
<p>Ao usar um mecanismo de hosting como IIS ou WAS, não é necessário criar um ServiceHost. Basta configurar o serviço e gerenciar pela ferramenta.</p>
<p>Há outro ponto que possivelmente esteja no exame. Antes do .NET 4.0, se você quisesse usar o IIS para hospedar seu serviço, você tinha que criar uma aplicação ASP.NET com uma referência ao seu serviço, colocar as configurações no Web.config e criar um arquivo de texto com a extenção .svc (com uma única linha) para mapear o serviço. </p>
<p>Com a versão 4.0, isso não é mais necessário. Você pode usar a classe <strong>ServiceHostingEnvironment</strong>, que permite que você referencie o arquivo .svc virtualmente, sem a necessidade de criá-lo fisicamente. A configuração via arquivo fica assim:</p>
<p><code>&lt;serviceHostingEnvironment&gt;<br />
  &lt;serviceActivations&gt;<br />
    &lt;add relativeAddress=&quot;ServiceOrInterfaceName.svc&quot; service=&quot;FullyQualifiedServiceName&quot;/&gt;<br />
  &lt;/serviceActivations&gt;<br />
&lt;/serviceHostingEnvironment&gt;<br />
</code></p>
<h2>Escolhendo Um Mecanismo De Hosting</h2>
<p>Resumindo o que vimos até agora, você tem várias opções para hospedar um serviço WCF:</p>
<ul>
<li>Windows Form application</li>
<li>Console application</li>
<li>Managed Windows Service</li>
<li>ASP.NET application</li>
<li>IIS</li>
<li>WAS</li>
<li>Windows Azure</li>
</ul>
<p>Não existe regra para fazer essa escolha ou uma opção que atenda todos os cenários. Se seu serviço demandar que o transporte não seja feito por HTTP, por exemplo, o IIS não é uma opção. Ou se você precisar usar um binding MSMQ, você vai precisar de um host que dê suporte a isso.</p>
<p>Falando no geral, procure uma solução que te dê menos trabalho. IIS e WAS são produtos confiáveis, com uma base de usuários grande e fáceis de usar em conjunto com WCF. Escrever um novo host fatalmente irá gerar bugs ao longo do caminho.</p>
<h2>Criando Serviços Transacionais</h2>
<p>No <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-1-3-implement-transactions/" target="_blank">objetivo 1.3</a>, falamos sobre a classe TransactionScope. Ela também funciona de maneira bem simples com serviços WCF.</p>
<p>Você precisa decorar a operação com o atributo TransactionFlow (em conjunto com o atributo OperationContract), que especifica se a operação suporta transações. O construtor aceita 3 valores:</p>
<ul>
<li><code>[TransactionFlow(TransactionFlowOption.NotAllowed)]</code>: a operação não pode participar de uma transaction;</li>
<li><code>[TransactionFlow(TransactionFlowOption.Allowed)]</code>: a operação pode participar de uma transaction, se o client iniciar uma;</li>
<li><code>[TransactionFlow(TransactionFlowOption.Mandatory)]</code>: obrigatoriamente a chamada deve fazer parte de uma transaction.</li>
</ul>
<p>Além disso, você deve setar as propriedades TransactionAutoComplete e TransactionScopeRequired do OperationBehavior como true:</p>
<p><code>[OperationBehavior(TransactionAutoComplete = true, TransactionScopeRequired = true)]<br />
public String GetTestSummary(String examId){}</code></p>
<p>TransactionAutoComplete diz ao runtime para automaticamente completar a transação se nenhuma exceção for lançada. Caso seja, será feito o rollback. O atributo TransactionScopeRequired diz que o método precisa fazer parte de uma TransactionScope.</p>
<h2>Hospedando Serviços Em Um Azure WorkerRole</h2>
<p>Hospedar seu serviço no Azure em um WorkerRole significa ter mais controle sobre o servidor e as configurações do seu serviço, permitindo que você não use o IIS como hosting, por exemplo.</p>
<p>Com isso, é de sua responsabilidade configurar endpoints, inicializar e abrir um ServiceHost. Isso pode ser feito no método OnStart.</p>
<p>As configurações de endpoint podem estar no arquivo de configuração da role (.csdef). O código fica assim:</p>
<p><script src="https://gist.github.com/edneypitta/117c18d38759fa885679.js"></script></p>
<p>É interessante deixar a variável de host fora do método para que o garbage collector não a remova do escopo quando o método terminar.</p>
<p>O último detalhe desse objetivo, não relacionado a nenhum item, é que você deve saber que existe um <strong>DiscoveryEndpoint</strong> que faz com que seu serviço seja descoberto por clients.</p>
<hr />
<p>E acabamos o capítulo 3 sobre serviços WCF 😀 Por ser o maior objetivo da certificação, o assunto ficou bem extenso e chato, às vezes. </p>
<p>Mas agora vem o capítulo 4 com os objetivos sobre Web API, que é o mais comum nas aplicações hoje em dia (e bem mais elegante).</p>
<p>O próximo objetivo será o 4.1,<strong> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-4-1-design-a-web-api/">Design a Web API</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/" title="Certificação Microsoft 70-487: Objetivo 3.9 – Host and manage services">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-469" class="post-469 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" title="Certificação Microsoft 70-487: Objetivo 3.8 – Implement messaging patterns" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.8 – Implement messaging patterns</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T15:25:10+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:18+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/#respond"><span class="dsq-postid" data-dsqidentifier="469 https://edneypitta.github.io/old-blog/?p=469">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
O objetivo 3.8, Implement messaging patterns, trata de <em>Message Exchange Patterns</em> (ou Padrões de Troca de Mensagem), que são mecanismos que descrevem como o client e o server vão se comunicar.<br />
Vamos cobrir como implementar os tipos one-way, request/reply, streaming e duplex, além de falar sobre alguns mecanismos no Azure. Vamos lá?</p>
<h2>Implementando One-Way, Request/Reply, Streaming e Duplex</h2>
<h4>One-Way</h4>
<p>Implementações one-way servem para cenários <em>fire and forget</em>, onde você faz uma chamada e não se importa com a resposta, como escrever alguma coisa em um log.</p>
<p>O WCF suporta implementações one-way de forma simples. Basta setar o parâmetro IsOneWay como true no atributo OperationContract e não ter nenhum tipo de retorno no método: </p>
<p><code>[OperationContract(IsOneWay = true)]<br />
void LogMessage(String message);</code></p>
<p>Num cenário comum, um request é feito para o servidor que processa e envia um response. Com OneWay, acontece o seguinte: quando o request é feito, o servidor responde instantaneamente com o StatusCode 202, Accepted. Só depois disso ele vai de fato processar o request, como se fosse uma operação assíncrona.</p>
<p>Apesar de ser uma boa feature, OneWay deve ser usado com cuidado. Operações críticas podem dar errado sem que você saiba, causando problemas. Bons candidatos a OneWay são operações de baixa prioridade e que não retornam valor.</p>
<h4>Streaming</h4>
<p>Ao implementar streaming com WCF, você tem dois modos para trabalhar: <strong>Buffered</strong> ou <strong>Streaming</strong>. </p>
<p>Buffered, o modo default, significa que a mensagem inteira precisa ser enviada para que o recebedor comece a leitura. Em Streaming, o recebedor consegue começar a leitura assim que a informação estiver disponível (cenário ideal para transferência de arquivos grandes, como áudio ou vídeo).</p>
<p>Nesse formato, uma propriedade importante é a maxReceivedMessageSize, que limita o tamanho de mensagens recebidas. Isso é crucial para evitar ataques DDoS.<br />
No nível do contrato, você começa o processo definindo o retorno de um método como Stream. Depois é necessário configurar o binding para que o TransferMode seja Streamed e aí configurar o atributo maxReceivedMessageSize. O arquivo de configuração ficaria assim:</p>
<p><script src="https://gist.github.com/edneypitta/6b14037220816e6274db.js"></script></p>
<p>Há 4 valores para o enum TransferMode, com nomes bem sugestivos: <em>Buffered</em>, <em>Streamed</em>, <em>StreamedRequest </em>e <em>StreamedResponse</em>.</p>
<p>Um ponto para se ter em mente é que habilitar streaming para um serviço não vai automaticamente melhorar a performance. É verdade que com streaming não são necessários grandes buffers de memória, mas num contexto comum de transferência de informações a melhora de performance é imperceptível. </p>
<p>Outro aspecto é que nem todos os bindings suportam a propriedade TransferMode. Os únicos bindings padrão que aceitam são <em>BasicHttpBinding</em>, <em>NetTcpBinding </em>e <em>NetNamedPipeBinding</em>.</p>
<p>Por último, há algumas limitações ao se usar streaming. São elas:</p>
<ul>
<li>Operações que usam o transporte Streamed só podem ter um input e um output de parâmetro;</li>
<li>Headers SOAP são sempre buffered, mesmo habilitando streaming. Eles não podem ultrapassar o tamanho da propriedade MaxBufferSize;</li>
<li>As implementações de segurança Reliable Message e SOAP Message confiam na transmissão buffered. Geralmente você deve usar segurança no nível de transporte (<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/" target="_blank">objetivo 3.4</a>).</li>
</ul>
<h4>Request/Reply</h4>
<p>É o modo padrão de funcionamento de qualquer web service, onde o client envia um request, o server processa e envia um response. Não há muito a mais o que ser dito 😀 Vamos para o próximo item.</p>
<h4>Duplex</h4>
<p>Na comunicação duplex, o client se conecta com um serviço provendo um canal de comunicação, onde o server pode mandar mensagens de volta para o client. Para funcionar, tudo isso precisa existir no contexto de uma sessão.</p>
<p>Nesse cenário com WCF, além de definir um contrato de ServiceContract, outra interface é necessária para especificar a propriedade CallbackContract, que serve como callback. Para o exame, não é necessário saber mais que isso existe.</p>
<h2>Implementando Azure Service Bus E Azure Queues</h2>
<p>Como visto no <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" target="_blank">objetivo anterior</a>, o Azure Service Bus é um componente que conecta serviços WCF (e outras aplicações) pelo Azure.</p>
<p>Usando relay, a comunicação é feita diretamente entre as duas partes. Isso implica que ambas precisam estar online para a comunicação acontecer.<br />
Às vezes, você precisa de uma fila de comunicações ou usar um mecanismo de <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank">publish/subscribe</a>. O Azure também oferece essas tipos de comunicações.</p>
<p>Uma <em>Queue </em>(fila) permite que mensagens enviadas por um client sejam armazenadas até que outro client as leia. Um <em>Topic</em> extende o comportamento da queue adicionando <em>subscriptions</em>, onde cada client especifica critérios para filtrar as mensagens que vê. Como Topics não estarão no exame, vamos focar na Queue.</p>
<p>Quando usando uma Queue, você manda uma mensagem para o service bus com um conjunto de propriedades chave/valor e um body binário. A mensagem é armazenada pelo service bus e entregada a um recebedor em um determinado momento, desacoplando as duas (ou mais) aplicações. O recebedor pode remover o item da fila na leitura ou colocar um lock, processar a mensagem e depois removê-la (como o Storage Queue faz).</p>
<p>Questões sobre a implementação não são prováveis de estar no exame, então o conhecimento do mecanismo já é suficiente. Você pode obter mais detalhes <a href="https://azure.microsoft.com/en-us/documentation/articles/service-bus-dotnet-multi-tier-app-using-service-bus-queues/" target="_blank">aqui</a>.</p>
<p>O conceito importante é o uso da classe QueueClient que permite o envio e recebimento de mensagens da queue. A mensagem é representada pela classe BrokeredMessage.</p>
<p>E chegamos ao final desse objetivo.<br />
O próximo post, sobre o objetivo <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-9-host-and-manage-services/">Host and manage services</a></strong>, será o último do capítulo sobre WCF.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/" title="Certificação Microsoft 70-487: Objetivo 3.8 – Implement messaging patterns">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-461" class="post-461 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" title="Certificação Microsoft 70-487: Objetivo 3.7 – Create and configure a WCF service on Windows Azure" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.7 – Create and configure a WCF service on Windows Azure</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T11:37:02+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:10+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/#respond"><span class="dsq-postid" data-dsqidentifier="461 https://edneypitta.github.io/old-blog/?p=461">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>O objetivo Create and configure a WCF service on Windows Azure (finalmente sobre Azure) fala principalmente sobre o <strong>Azure Service Bus</strong>, serviço que permite que você exponha seu serviço WCF (ou qualquer outro) hospedado no seu próprio datacenter. Isso evita os problemas de instalação e configuração de deixar tudo <em>on premises</em> e te dá as vantagens que o Azure pode oferecer. Vamos lá?</p>
<h2>Criando E Configurando Bindings</h2>
<p>Apenas revisando, um serviço WCF basicamente precisa do ABC (address, binding e contract). Para fazer o deploy de um serviço WCF no Azure em uma Web Role ou Web Site você não precisa fazer nenhuma modificação no código ou nas configurações.</p>
<p>Usando a feature de <em>relay</em> do Azure Service Bus, você pode configurar alguns bindings adicionais no seu projeto adicionando o pacote NuGet <strong>Windows Azure Service Bus</strong>.</p>
<p>Considere o código a seguir, assumindo que ISecretService e SecretService formam o contrato e a implementação de um serviço:</p>
<p><script src="https://gist.github.com/edneypitta/a9a868a8cd8013f3551e.js"></script></p>
<p>Nesse exemplo, o serviço está exposto em dois endpoints, um interno (com NetTcpBinding) e um externo, usando a feature de relay do Azure Service Bus (com NetTcpRelayBinding). Ao fechar a aplicação (sh.Close()), o endpoint é removido do Azure.</p>
<p>Você pode configurar também o endpoint no Azure pelo arquivo de configuração:</p>
<p><script src="https://gist.github.com/edneypitta/37e5fbf9ad2587f2443b.js"></script></p>
<p>Nos dois exemplos o binding NetTcpRelayBinding é usado, mas há outros disponíveis.<br />
Tanto por código ou arquivo de configuração, você deve setar o nome do serviço e a Default Key.<br />
Outro ponto interessante é que o Azure Service Bus não requer nenhuma configuração no seu servidor on premise. Normalmente a comunicação é feita por TCP, mas se as portas não estiverem disponíveis, o relay pode usar as portas HTTP ou HTTPS.</p>
<h2>Criando Um Azure Service Bus</h2>
<p>Para criar um Azure Service Bus, basta ir no portal do Azure, selecionar a criação de um Azure Service Bus, configurar um namespace e selecionar uma região.</p>
<p>O portal vai informar a connection string de conexão, que contém o nome do serviço e a Default Key:</p>
<p><code><strong>Endpoint</strong>=sb://wcfonazure.servicebus.windows.net/;<strong>SharedSecretIssuer</strong>=owner;<strong>SharedSecretValue</strong>=D1Kmb83CCLrAtz4du9vb3xn99DaM2dH4jQqSec98if4=<br />
</code></p>
<h2>Integrando Com O Azure Service Bus Relay</h2>
<p>Após criar um novo service bus no Azure e hospedar um serviço WCF, você pode criar um client para se comunicar com seu serviço on premise pelo Azure.</p>
<p>É necessário ter o namespace especificado, o nome do serviço e a Default Key. O código a seguir mostra como o consumo pode ser feito via ChannelFactory:</p>
<p><script src="https://gist.github.com/edneypitta/02832ee8fc50835b373b.js"></script></p>
<p>O método CreateSharedSecretTokenProvider se autentica no service bus pelo owner e a key, mas há outros mecanismos de autenticação como SAML ou SimpleWebToken.</p>
<p>Isso é tudo 🙂<br />
O próximo post será sobre o objetivo 3.8, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-8-implement-messaging-patterns/">Implement messaging patterns</a></strong>.</p>
<p>Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/" title="Certificação Microsoft 70-487: Objetivo 3.7 – Create and configure a WCF service on Windows Azure">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-456" class="post-456 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" title="Certificação Microsoft 70-487: Objetivo 3.6 – Version a WCF service" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.6 – Version a WCF service</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T10:37:00+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:54+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/#comments"><span class="dsq-postid" data-dsqidentifier="456 https://edneypitta.github.io/old-blog/?p=456">1 Comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá pessoal!<br />
Continuando a série sobre a certificação Microsoft 70-487, esse post será sobre o objetivo 3.6, Version a WCF service.<br />
Esse objetivo, que é bem curto, cobre os conceitos sobre como versionar diferentes tipos de contratos e informações de bindings.</p>
<p>Várias mudanças podem ocorrer no ciclo de vida de um serviço WCF: no contrato, no endereço (address), nos bindings, na implementação de algum método, etc. Essas mudançar podem ser classificadas em <em>breaking changes</em> ou <em>Nonbreaking changes</em>.</p>
<p>Há 2 tipos de versionamento: <em>strict </em>e <em>lax</em>.</p>
<p>O versionamento strict é quando você tem um ou mais clients que não toleram mudanças no serviço. Nesse caso, <strong>todas </strong>as mudanças precisam levar isso em conta e você nunca deve modificar algum comportamento; apenas adicionar em outras versões ou namespaces.</p>
<p>No versionamento lax, suportado pelo WCF e até web services .asmx, você pode fazer pequenas alterações sem quebrar o contrato existente. É possível, por exemplo, adicionar um novo membro fazendo com que os dados sejam somente ignorados por clients antigos.</p>
<p>Esse objetivo é bem conceitual e saber quando uma mudança vai quebrar ou não um serviço é suficiente para o exame. Mudanças no contrato são breaking changes; adições no DataContract podem ser ignoradas por clients antigos e não vão quebrar a funcionalidade.</p>
<p>E é <strong>só</strong> isso 🙂<br />
O próximo objetivo, também curto, será o <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-7-create-and-configure-a-wcf-service-on-windows-azure/">Create and configure a WCF service on Windows Azure</a></strong>.</p>
<p>Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/" title="Certificação Microsoft 70-487: Objetivo 3.6 – Version a WCF service">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-441" class="post-441 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" title="Certificação Microsoft 70-487: Objetivo 3.5 – Consume WCF services" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.5 – Consume WCF services</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" rel="bookmark"><time class="entry-date published" datetime="2016-02-20T09:54:44+00:00">20/02/2016</time><time class="updated" datetime="2016-03-01T16:58:06+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/#respond"><span class="dsq-postid" data-dsqidentifier="441 https://edneypitta.github.io/old-blog/?p=441">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Olá!<br />
Hoje vamos falar sobre o objetivo 3.5 da certificação 70-487, <strong>Consume WCF services</strong>.<br />
Esse objetivo cobre como consumir um serviço WCF de 3 formas: gerando classes proxy com Svcutil.exe, gerando classes proxy adicionando uma referência ao serviço e consumindo via ChannelFactory. Vamos lá?</p>
<h2>Gerando Proxies Com Svcutil.exe</h2>
<p>É possível consumir serviços WCF gerando uma classe proxy e interagindo com ela como se fosse uma classe comum, deixando o framework fazer toda a comunicação por trás.</p>
<p>O Svcutil.exe, uma ferramenta chamada pela linha de comando, é uma das formas de gerar classes proxy de um serviço WCF. É possível fazer a geração baseado em serviços existentes ou metadata. </p>
<p>A ferramenta também permite que você exporte metadata de um serviço, valide código de um serviço, faça download dos metadatas de serviços existentes e gere código de serialização.</p>
<p>A melhor maneira de estudar para o exame é criar alguns serviços e gerar as proxies chamando o Svcutil.exe com opções diferentes, analisando o que a ferramenta de fato faz. A lista abaixo traz as opções importantes para o exame ao chamar a ferramenta pela linha de comando (atalhos estão entre parênteses):</p>
<ul>
<li><strong>/directory:&lt;directory&gt; (/d)</strong>: especifica o diretório em que os arquivos gerados serão colocados. Se não for especificado, o diretório atual será usado. Caso o diretório já tenha sido usado, o Svcutil.exe irá sobrescrever os arquivos;</li>
<li><strong>/mergeConfig</strong>: caso o diretório já tenha sido usado, ao invés de sobrescrever os arquivos, com essa opção o Svcutil.exe irá fazer o merge das configurações;</li>
<li><strong>/help (/?)</strong>: lista as opções disponíveis;</li>
<li><strong>/noLogo</strong>: tira as informações Logo (copyright e mensagem de banner);</li>
<li><strong>/svcutilConfig:&lt;configFile&gt;</strong>: coloca as configurações no arquivo especificado. O default é o App.config;</li>
<li><strong>/target:&lt;output type&gt; (/t)</strong>: instrui a ferramenta a criar um output específico. As opções são <em>code</em>, <em>metadata</em> e <em>xmlSerializer</em>;</li>
<li><strong>/async (/a)</strong>: cria todos os métodos das classes proxy com a versão normal e uma Async;</li>
<li><strong>/internal (/i)</strong>: cria todos os métodos das classes proxy como <em>internal</em>, e não <em>public</em>;</li>
<li><strong>/serializer (/ser)</strong>: gera os tipos com um serializer específico. As opções são <em>Auto</em>, <em>DataContractSerializer</em> e <em>XmlSerializer</em>;</li>
<li><strong>/out (/o)</strong>: especifica o nome do arquivo para o código gerado;</li>
<li><strong>/language (/l)</strong>: especifica uma linguagem para o código gerado. As opções são <em>c#</em>, <em>cs</em>, <em>csharp</em>, <em>vb</em>, <em>visualbasic</em>, <em>c++</em> e <em>cpp</em>.</li>
</ul>
<h2>Gerando Proxies Por Referência</h2>
<p>Uma feature do Visual Studio é a possibilidade de gerar classes proxy adicionando uma referência a um serviço.<br />
Basta clicar com o botão direito no seu projeto e ir em Add Service Reference. A seguinte tela é mostrada:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/21.png" alt="add service" width="574" height="466" class="alignnone size-full wp-image-446" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/21.png 574w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/21-300x244.png 300w" sizes="(max-width: 574px) 100vw, 574px" /></p>
<p>Você pode prover uma URL de um serviço (com metadata habilitado) ou clicar no botão Discover para encontrar services que estão na mesma solution. Após clicar em Go, os serviços são listados e você pode especificar um namespace, o que é recomendado.</p>
<p>Ao clicar em Advanced abaixo, a tela Service Reference Settings é aberta:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/31.png" alt="service reference settings" width="590" height="607" class="alignnone size-full wp-image-448" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/31.png 590w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/31-292x300.png 292w" sizes="(max-width: 590px) 100vw, 590px" /></p>
<p>No topo você pode especificar o modificador de acesso e se métodos async devem ser gerados, como as opções /internal e /async usando Svcutil.exe.<br />
A opção Always Generate Message Contracts faz o que o nome diz, gera classes para os contratos.</p>
<p>Na seção Data Type, você pode definir o tipo das coleções. Nada te impede de usar generics (List&lt;T&gt;), mas geralmente arrays são utilizados para manter a compatibilidade entre diferentes clients que não sejam .NET.</p>
<p>A última seção, Compatibility, serve se você estiver consumindo um web service antigo <em>.asmx</em>. A tela Add Web Reference é aberta:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/41.png" alt="add web reference" width="848" height="593" class="alignnone size-full wp-image-449" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/41.png 848w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/41-300x210.png 300w" sizes="(max-width: 848px) 100vw, 848px" /></p>
<h2>Criando E Implementando ChannelFactories</h2>
<p>A classe ChannelFactory serve para fazer comunicações com endpoints de forma simples. Ela pode atuar em conjunto com o arquivo de configuração da sua aplicação, fazendo com que uma chamada a um serviço tenha 2 linhas de código.</p>
<p>A primeira coisa que você deve saber é que a classe ChannelFactory trabalha com o contrato do serviço, então você deve ter uma referência à interface que especifica o contrato.</p>
<h4>Construtores</h4>
<p>O construtor padrão não aceita nenhum parâmetro, então informações sobre o endpoint precisam ser especificadas: <code>new ChannelFactory<ITestService>()</code>.</p>
<p>O próximo aceita uma string com o nome de configuração do endpoint:</p>
<p><code>String endpointConfigName = "wsHttp_BindingConfig";<br />
ChannelFactory&lt;ITestService&gt; proxy = new ChannelFactory&lt;ITestService&gt;(endpointConfigName);</code></p>
<p>Outro aceita um binding, mas funciona da mesma forma:</p>
<p><code>String endpointConfigName = "wsHttp_BindingConfig";<br />
WSHttpBinding wSBinding = new WSHttpBinding(EndpointConfigName);<br />
ChannelFactory&lt;ITestService&gt; proxy = new ChannelFactory&lt;ITestService&gt;(wSBinding);</code></p>
<p>O próximo aceita um ServiceEndpoint:</p>
<p><code>ServiceEndpoint endpoint = new ServiceEndpoint(new ContractDescription("Endpoint"));<br />
ChannelFactory&lt;ITestService&gt; proxy = new ChannelFactory&lt;ITestService&gt;(endpoint);</code></p>
<p>Há outros construtores que são bem intuitivos. Vamos a um cenário real de uso da classe ChannelFactory, algo bem provável de conter pelo menos 1 questão no exame:</p>
<p><script src="https://gist.github.com/edneypitta/d96af1c3b703d014e693.js"></script></p>
<p>O método CreateChannel inicializa a ChannelFactory, retornando o tipo do contrato especificado no construtor. Depois disso, basta chamar os métodos desejados que estão no contrato. Por fim, chame o método Close. Ele possui uma chamada padrão sem parâmetros e uma recebendo um TimeSpan, onde você indica que se o canal não for fechado nesse tempo uma exceção é lançada.</p>
<p>Por último, é importante destacar que com ChannelFactory você não precisa da classe de definição do serviço, apenas a interface do contrato.</p>
<p>Isso é tudo para esse objetivo 🙂<br />
Obrigado pela leitura e fique de olho no post do próximo objetivo, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-6-version-a-wcf-service/">Version a WCF service</a></strong>.</p>
<p>Até mais!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/" title="Certificação Microsoft 70-487: Objetivo 3.5 – Consume WCF services">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-433" class="post-433 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/" title="Certificação Microsoft 70-487: Objetivo 3.4 – Secure a WCF service" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.4 – Secure a WCF service</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/" rel="bookmark"><time class="entry-date published" datetime="2016-02-16T23:18:40+00:00">16/02/2016</time><time class="updated" datetime="2016-03-01T16:57:42+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/#respond"><span class="dsq-postid" data-dsqidentifier="433 https://edneypitta.github.io/old-blog/?p=433">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>O objetivo 3.4 do exame, <strong>Secure a WCF service</strong>, cobre as features de segurança que o WCF disponibiliza. Isso inclui 1) como implementar segurança no nível de mensagem, 2) como implementar segurança no nível de transporte e 3) como implementar <em>certificates</em>, que é a combinação dos itens anteriores. Vamos lá?</p>
<h2>Implementando Segurança no Nível de Mensagem</h2>
<p>Basicamente, implementar segurança no nível da mensagem é &#8220;incrementar&#8221; as mensagens SOAP com 3 características CIA:</p>
<ul>
<li><strong>Confidencialidade</strong>: significa que somente as pessoas que devem ver uma mensagem são as pessoas que de fato vejam a mensagem;</li>
<li><strong>Integridade</strong>: significa que a mensagem não pode ser alterada;</li>
<li><strong>Autenticação</strong>: garante a identidade de quem está vendo a mensagem.</li>
</ul>
<p>Isso significa que a mensagem não é visualizada sem a chave correspondente, mas o texto criptografado pode ser visto na rede.</p>
<p>Na maioria dos bindings, isso é feito por padrão e roda transparentemente, sem intervenção do desenvolvedor. Você pode também especificar via código ou arquivo de configuração.</p>
<p>Por código, basta setar a propriedade Security.Mode do binding desejado, seja por construtor ou setando a propriedade manualmente:</p>
<p><code>// Set Security Mode to Message in Constructor<br />
WSHttpBinding WsHttpSecurity = new WSHttpBinding(SecurityMode.Message);</code></p>
<p><code>// Set the Security property manually<br />
WSHttpBinding wsHttpSecurity2 = new WSHttpBinding();<br />
wsHttpSecurity2.Security.Mode = SecurityMode.Message;</code></p>
<p>A propriedade Mode para o wsHttpBinding é do tipo <strong>SecurityMode</strong>. Para o basicHttpBinding o tipo é <strong>BasicHttpSecurityMode </strong>e para o netNamedPipeBinding é <strong>NetNamedPipeSecurityMode</strong>.</p>
<p>É possível fazer essa configuração no arquivo de configuração pelo WCF Service Configuration Editor. Para cada binding configurado, há duas abas no editor: Binding e Security. Basta ir na aba Security e setar o Mode para Message:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/11.png" alt="security mode" width="686" height="494" class="alignnone size-full wp-image-435" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/11.png 686w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/11-300x216.png 300w" sizes="(max-width: 686px) 100vw, 686px" /></p>
<p>Se você for para o arquivo de configuração, verá que nada foi adicionado pois o wsHttpBinding faz essa segurança por padrão. Contudo, é possível declarar também explicitamente dessa forma:</p>
<p><code>&lt;wsHttpBinding&gt;<br />
 &lt;binding name=&quot;wsHttpBindingConfigSample&quot; &gt;<br />
 &lt;security mode=&quot;Message&quot;/&gt;<br />
 &lt;/binding&gt;<br />
 &lt;/wsHttpBinding&gt;</code></p>
<h2>Implementando Segurança no Nível de Transporte</h2>
<p>Transporte seguro significa que todo o transporte é criptografado, tornando difícil para um interceptor compreender a mensagem. Com isso, o texto da mensagem não precisa ser criptografado; pode ser trafegado em plain text.</p>
<p>Implementar segurança no nível de transporte é virtualmente idêntico ao item anterior. A diferença é que, ao invés de setar o Mode como Message, você deve escolher <strong>Transport </strong>ou <strong>TransportWithMessageCredential</strong></p>
<p>Seja via código ou arquivo de configuração, o funcionamento é exatamente o mesmo.</p>
<h2>Implementando Certificates</h2>
<p>Para usar certificados, você precisa adicionar uma referência a <em>System.Security.dll</em>. Com o certificado instalado, a configuração no WCF é bem simples. </p>
<p>Assumindo que você tenha um netHttpBinding configurado para o serviço, basta sincronizar os elementos &lt;security&gt; e &lt;message&gt; para que o Mode da propriedade Security seja TransportWithMessageCredential e a propriedade ClientCredentialType da mensagem seja o certificado. </p>
<p>Após essa configuração, basta garantir que certificado está instalado no client, obter uma referência a ele e adicioná-lo na propriedade <em>Credentials.ClientCredentials.Certificate</em>:</p>
<p><code>var MyFactory = new ChannelFactory<ITestService>("*");<br />
MyFactory.Credentials.ClientCredentials.Certificate = X509.CurrentUser.My.SubjectDistinguishedName.Find("CN=CLIENT").FirstOrDefault();</code></p>
<p>Isso é tudo para esse objetivo 🙂 O próximo post será sobre o objetivo 3.5, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-5-consume-wcf-services/">Consume WCF services</a></strong>.</p>
<p>Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/" title="Certificação Microsoft 70-487: Objetivo 3.4 – Secure a WCF service">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-411" class="post-411 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-3-configure-wcf-services-by-using-the-api/" title="Certificação Microsoft 70-487: Objetivo 3.3 – Configure WCF services by using the API" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-3-configure-wcf-services-by-using-the-api/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.3 – Configure WCF services by using the API</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-3-configure-wcf-services-by-using-the-api/" rel="bookmark"><time class="entry-date published" datetime="2016-02-16T07:41:55+00:00">16/02/2016</time><time class="updated" datetime="2016-03-01T16:57:25+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-3-configure-wcf-services-by-using-the-api/#comments"><span class="dsq-postid" data-dsqidentifier="411 https://edneypitta.github.io/old-blog/?p=411">1 Comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>O objetivo 3.3 da certificação Microsoft 70-487, Configure WCF services by using the API, trata dos mesmos aspectos do <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-2-configure-wcf-services-by-using-configuration-settings/">objetivo anterior</a>. A diferença é que enquanto no objetivo 3.2 vimos como alterar as configurações de um serviço WCF via arquivo de configuração, nesse vamos ver como fazer essas configurações via código, ou API. </p>
<h2>Configurando Comportamentos do Serviço</h2>
<p>Como configuramos os behaviors no post anterior com ServiceBehaviors e EndpointBehaviors, podemos fazer as mesmas configurações com os atributos <strong>ServiceBehaviorAttribute </strong>e <strong>OperationBehaviorAttribute</strong>.<br />
ServiceBehaviorAttribute é do mesmo nível que ServiceContract, então os behaviors são configurados no nível de serviço e se aplicam ao serviço inteiro. OperationBehaviorAttribute se equivale ao OperationContract, ou seja, a cada método do serviço. </p>
<p>ServiceBehaviorAttribute não pode decorar a interface do contrato, somente a implementação (classe). A lista das propriedades pode ser consultada na <a href="https://msdn.microsoft.com/pt-br/library/system.servicemodel.servicebehaviorattribute(v=vs.110).aspx" target="_blank">MSDN</a>.</p>
<p>Uma questão provável de cair no exame é sobre concorrência de ServiceContractAttribute e ServiceBehaviorAttribute. Por exemplo, ambas têm as propriedades Name e Namespace, resultando no seguinte cenário:</p>
<p><code>[ServiceContract(<strong>Namespace</strong>="http://www.williamgryan.mobi/Books/70-487", <strong>Name</strong>="RandomText")]<br />
public interface ITestService{}<br />
[ServiceBehavior(<strong>Name</strong>="Test", <strong>Namespace</strong>="http://www.williamgryan.mobi/Books/70-487/Services")]<br />
public class TestService : ITestService<br />
{}</code></p>
<p>O resultado do envelope do request é o seguinte:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/8.png" alt="request envelope" width="967" height="180" class="alignnone size-full wp-image-414" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/8.png 967w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/8-300x56.png 300w" sizes="(max-width: 967px) 100vw, 967px" /></p>
<p>Aqui o namespace (xmlns) é o definido no ServiceContract. Note o que acontece no MetadataExchange, quando você adiciona uma referência ao serviço em um client, e no WSDL:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/9.png" alt="reference" width="600" height="486" class="alignnone size-full wp-image-415" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/9.png 600w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/9-300x243.png 300w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/10.png" alt="wsdl" width="978" height="483" class="alignnone size-full wp-image-416" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/10.png 978w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/10-300x148.png 300w" sizes="(max-width: 978px) 100vw, 978px" /></p>
<p>Isso mostra que o ServiceBehaviorAttribute seta os valores de Name e Namespace no elemento service dentro do WSDL. Quando definidos no ServiceContract, eles ficam no WSDL.</p>
<h2>Configurando Bindings</h2>
<p>Assim como no arquivo de configuração, há vários bindings disponíveis para se configurar via API. Todos eles funcionam de forma quase idêntica, apenas com pequenas diferenças. Vamos passar pelos 5 mais comuns, incluindo custom binding.</p>
<h4>BasicHttpBinding</h4>
<p>BasicHttpBinding é o mais simples dos bindings disponíveis. Funciona via HTTP, precisa da especificação do SOAP 1.1 e tem poucos recursos de segurança. Ele possui 3 construtores:</p>
<ul>
<li><strong>new BasicHttpBinding()</strong>: deixa o WCF lidar com os valores default de configuração;</li>
<li><strong>new BasicHttpBinding(BasicHttpSecurityMode)</strong>: recebe um BasicHttpSecurityMode que tem os seguintes valores: None, Transport, Message e TransportCredentialOnly;</li>
<li><strong>new BasicHttpBinding(string)</strong>: recebe o nome de um binding no arquivo de configuração.</li>
</ul>
<h4>wsHttpBinding</h4>
<p>Funciona via HTTP como o BasicHttpBinding, mas possui 2 principais vantagens: usa o padrão SOAP 1.2 e tem suporte ao padrão WS-*, que contempla features como Reliable Messaging, transações, comunicação <em>duplex</em>, etc.</p>
<p>wsHttpBinding tem 4 construtores:</p>
<ul>
<li><strong>new WSHttpBinding()</strong>: deixa o WCF lidar com os valores default de configuração;</li>
<li><strong>new WSHttpBinding(SecurityMode)</strong>: recebe um BasicHttpSecurityMode que tem os seguintes valores: None, Transport, Message e TransportWithMessageCredential;</li>
<li><strong>new WSHttpBinding(string)</strong>: recebe o nome de um binding no arquivo de configuração;</li>
<li><strong>new WSHttpBinding(SecurityMode, bool)</strong>: recebe um SecurityMode e um bool que habilita ReliableSession</li>
</ul>
<h4>NetMsmqBinding</h4>
<p>Implementação quase idêntica à de um wsHttpBinding. A diferença é que usa o enum MsmqSecurityMode para opções de segurança e não há suporte para Reliable Messaging:</p>
<ul>
<li><strong>new NetMsmqBinding()</strong>: deixa o WCF lidar com os valores default de configuração;</li>
<li><strong>new NetMsmqBinding(NetMsmqSecurityMode)</strong>: recebe um NetMsmqSecurityModeque tem os seguintes valores: Transport, Message, Both e None;</li>
<li><strong>new NetMsmqBinding(string)</strong>: recebe o nome de um binding no arquivo de configuração.</li>
</ul>
<h4>NetNamedPipeBinding</h4>
<p>NetNamedPipeBinding é usado para comunicação entre serviços na mesma máquina, tendo um grande nível de performance.</p>
<p>Como o NetMsmqBinding Implementação quase idêntica à de um wsHttpBinding. A diferença é que usa o enum MsmqSecurityMode para opções de segurança e não há suporte para Reliable Messaging:</p>
<ul>
<li><strong>new NetMsmqBinding()</strong>: deixa o WCF lidar com os valores default de configuração;</li>
<li><strong>new NetMsmqBinding(NetMsmqSecurityMode)</strong>: recebe um NetMsmqSecurityModeque tem os seguintes valores: Transport, Message, Both e None;</li>
<li><strong>new NetMsmqBinding(string)</strong>: recebe o nome de um binding no arquivo de configuração.</li>
</ul>
<h4>Custom Binding</h4>
<p>Para implementar um binding customizado, você pode usar um ou mais dos predefinidos e adicionar features ou implementar um exclusivo.</p>
<p>O elemento <em>&lt;customBinding&gt;</em> é utilizado para se definir um binding customizado. Há um processo a se seguir com ordem específica:</p>
<ol>
<li>O item mais externo é o <strong>TransactionFlowBindingElement</strong>. É opcional, necessário somente se você quiser suportar Flowing Transactions;</li>
<li><strong>ReliableSessionBindingElement</strong>, também opcional, indica se Reliable Sessions devem ser suportadas;</li>
<li><strong>SecurityBindingElement</strong> define funcionalidades de segurança como autorização, autenticação, proteção, confidencialidade, etc. Também opcional;</li>
<li>O próximo item da cadeia é o <strong>CompositeDuplexBindingElement</strong>, caso comunicações duplex sejam suportadas;</li>
<li>O elemento <strong>OneWayBindingElement</strong> pode ser usado se você quiser prover comunicações OneWay para o serviço;</li>
<li>Dois elementos podem ser implementados para prover Stream Security: <strong>SslStreamSecurityBindingElement </strong>e <strong>WindowsStreamSecurityBindingElement</strong>. Implementação opcional;</li>
<li>O próximo item se trata do encoding da mensagem. Ao contrário dos outros, esse é obrigatório na implementação de um custom binding. Há 3 encodings disponíveis: <strong>TextMessageEncodingBindingElement</strong>, <strong>BinaryMessageEncodingBindingElement</strong>, e <strong>MtomMessageEncodingBindingElement</strong>;</li>
<li>O último e obrigatório item é o elemento de transporte. Há 8 opções disponíveis: <strong>TcpTransportBindingElement</strong>,  <strong>HttpTransportBindingElement</strong>, <strong>HttpsTransportBindingElement</strong>, <strong>NamedPipeTransportBindingElement</strong>, <strong>PeerTransportBindingElement</strong>, <strong>MsmqTransportBindingElement</strong>, <strong>MsmqIntegrationBindingElement </strong>e <strong>ConnectionOrientedTransportBindingElement</strong>.</li>
</ol>
<h2>Especificando Contratos</h2>
<p>Essa seção é uma revisão de como se define um serviço WCF:</p>
<ul>
<li>Defina um contrato usando o atributo <strong>ServiceContract</strong>;</li>
<li>Defina as operações com o atributo <strong>OperationContract</strong>;</li>
<li>Defina as classes que serão transportadas com os atributos <strong>DataContract </strong>e <strong>DataMember</strong>.</li>
</ul>
<p>Um ponto é que o atributo ServiceContract pode ser definido tanto na classe de implementação quanto na interface, mas não em ambas. Caso isso aconteça, uma InvalidOperationException é lançada ao tentar referenciar esse serviço. O mesmo ocorre com o atributo OperationContract.</p>
<p>O último detalhe é que o construtor padrão do ServiceContract seta 3 propriedades: Name (com o nome da classe), Namespace (com &#8220;http://tempuri.org&#8221;) e ProtectionLevel para ProtectionLevelNone. É recomendável setar essas propriedades manualmente.</p>
<h2>Expondo Metadados</h2>
<p>Os atributos usados para se definir um serviço (ServiceContract e OperationContract) não expõem automaticamente os detalhes do serviço (metadados). </p>
<p>Você pode fazer isso definindo endpoints de <em>metadata exchange</em>. Atualmente há 4 bindings disponíveis: mexHttpBinding, mexHttpsBinding, mexNamedPipeBinding e mexTcpBinding (&#8220;mex&#8221; é uma combinação das palavras &#8220;metadata exchange&#8221;). </p>
<p>No arquivo de configuração, isso ficaria assim:</p>
<p><code>&lt;endpoint address=&quot;&quot; binding=&quot;basicHttpBinding&quot; contract=&quot;Samples.WCF.Services.ITestService&quot; /&gt;<br />
&lt;endpoint address=&quot;mex&quot; binding=&quot;mexHttpBinding&quot; <strong>contract=&quot;IMetadataExchange&quot;</strong> /&gt;</code></p>
<p>Note que o atributo contract sempre usa a interface <strong>IMetadataExchange</strong>.</p>
<p>Para adicionar o endpoint de metadata exchange via API, você pode usar a classe <strong>MetadataExchangeBindings</strong>. Vamos assumir que você está definindo o seguinte ServiceHost:</p>
<p><code>String uriString = "http://yourhost/Samples.WCF.Services/TestService/";<br />
Uri[] baseAddresses = new Uri[]{new Uri(uriString)};<br />
ServiceHost hoster = new ServiceHost(typeof(TestService), baseAddresses);</code></p>
<p>A classe MetadataExchangeBindings tem um método Create para cada binding disponível. Você adicionaria os endpoints assim:</p>
<ul>
<li>Hoster.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, MetadataExchangeBindings.<strong>CreateMexHttpBinding()</strong>, &#8220;mexBindingHttp&#8221;);</li>
<li>Hoster.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, MetadataExchangeBindings.<strong>CreateMexHttpsBinding()</strong>, &#8220;mexBindingHttps&#8221;);</li>
<li>Hoster.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, MetadataExchangeBindings.<strong>CreateMexTcpBinding()</strong>, &#8220;mexBindingTcp&#8221;);</li>
<li>Hoster.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, MetadataExchangeBindings.<strong>CreateMexNamedPipeBinding()</strong>, &#8220;mexBindingPipe&#8221;).</li>
</ul>
<p><em>ServiceMetadataBehavior.MexContractName</em> é apenas uma constante com o nome da interface IMetadataExchange.</p>
<p>Chegamos ao fim desse objetivo 🙂<br />
Obrigado pela leitura e fique de olho no post do próximo objetivo, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-4-secure-a-wcf-service/">Secure a WCF service</a></strong>.</p>
<p>Até mais! </p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-3-configure-wcf-services-by-using-the-api/" title="Certificação Microsoft 70-487: Objetivo 3.3 – Configure WCF services by using the API">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				
<article id="post-395" class="post-395 post type-post status-publish format-standard hentry category-certificacao tag-70-487">
	<div class="blog-item-wrap">
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-2-configure-wcf-services-by-using-configuration-settings/" title="Certificação Microsoft 70-487: Objetivo 3.2 – Configure WCF services by using configuration settings" >
			 				</a>
		<div class="post-inner-content">
			<header class="entry-header page-header">

				<h1 class="entry-title"><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-2-configure-wcf-services-by-using-configuration-settings/" rel="bookmark">Certificação Microsoft 70-487: Objetivo 3.2 – Configure WCF services by using configuration settings</a></h1>

								<div class="entry-meta">
					<span class="posted-on"><i class="fa fa-calendar"></i> <a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-2-configure-wcf-services-by-using-configuration-settings/" rel="bookmark"><time class="entry-date published" datetime="2016-02-08T14:37:17+00:00">08/02/2016</time><time class="updated" datetime="2016-03-01T16:57:19+00:00">01/03/2016</time></a></span><span class="byline"> <i class="fa fa-user"></i> <span class="author vcard"><a class="url fn n" href="https://edneypitta.github.io/old-blog/author/admin/">Edney Pitta</a></span></span>				<span class="comments-link"><i class="fa fa-comment-o"></i><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-2-configure-wcf-services-by-using-configuration-settings/#respond"><span class="dsq-postid" data-dsqidentifier="395 https://edneypitta.github.io/old-blog/?p=395">Deixe um comentário</span></a></span>
				
				
				</div><!-- .entry-meta -->
							</header><!-- .entry-header -->

						<div class="entry-content">

				<p>Vários comportamentos importantes de um serviço WCF podem ser configurados por arquivos de configurações. Esses arquivos são muito úteis na construção de uma aplicação, seja web ou WCF. Você pode controlar quase qualquer aspecto de um serviço sem a necessidade de rebuildar e redeployar a aplicação. O objetivo 3.2, Configure WCF services by using configuration settings, mostra que o exame vai cobrar conhecimentos sobre as possíveis configurações e como manipulá-las, no formato de drag and drop. Vamos lá?</p>
<h2>Configurando Comportamentos do Serviço</h2>
<p>O Visual Studio oferece uma ferramenta chamada <strong>WCF Service Configuration Editor</strong>, disponível no menu Tools. Ela permite a manipulação de arquivos de configuração visualmente, suportando até a criação de serviços. Segue abaixo o guia básico da criação e configuração de um serviço WCF:</p>
<h4>Criando Um Serviço</h4>
<p>Você pode escolher a opção Create a New Service, se ainda não tiver um serviço criado:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/1.png" alt="create a new service" width="787" height="577" class="aligncenter size-full wp-image-397" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/1.png 787w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/1-300x220.png 300w" sizes="(max-width: 787px) 100vw, 787px" /></p>
<p>A primeira coisa que o wizard faz é adicionar um elemento <system.ServiceModel> e um <services> no arquivo de configuração. Depois, apresenta a página New Service Element Wizard para você selecionar o assembly que contém o serviço:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/2.png" alt="select assembly" width="624" height="513" class="alignnone size-full wp-image-398" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/2.png 624w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/2-300x247.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></p>
<p>Após especificar o serviço, você precisa especificar os contratos correspondentes:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/3.png" alt="select contract" width="613" height="505" class="alignnone size-full wp-image-399" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/3.png 613w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/3-300x247.png 300w" sizes="(max-width: 613px) 100vw, 613px" /></p>
<p>Depois, o wizard prossegue para a definição da comunicação do serviço:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/4.png" alt="select communication mode" width="627" height="518" class="alignnone size-full wp-image-400" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/4.png 627w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/4-300x248.png 300w" sizes="(max-width: 627px) 100vw, 627px" /></p>
<p>Depois, o modo de interoperabilidade (básica ou avançada):</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/5.png" alt="select interoperability" width="627" height="520" class="alignnone size-full wp-image-401" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/5.png 627w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/5-300x249.png 300w" sizes="(max-width: 627px) 100vw, 627px" /></p>
<p>Por último, o wizard pede o endereço do endpoint e apresenta uma página que sumariza todas as informações dadas. O importante aqui é como o arquivo de configuração ficou após esses passos:</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br />
&lt;configuration&gt;<br />
 &lt;system.serviceModel&gt;<br />
 &lt;services&gt;<br />
 &lt;service name=&quot;Samples.WCF.Services.TestService&quot;&gt;<br />
 &lt;endpoint address=http://www.williamgryan.mobi/samples/487<br />
 binding=&quot;wsDualHttpBinding&quot; bindingConfiguration=&quot;&quot; name=&quot;DualHttp&quot;<br />
 contract=&quot;Samples.WCF.Services.ITestService&quot; /&gt;<br />
 &lt;/service&gt;<br />
 &lt;/services&gt;<br />
 &lt;/system.serviceModel&gt;<br />
&lt;/configuration&gt;</code></p>
<p>Você pode notar, pelo nome do nodo <strong>services</strong>, que mais de um serviço pode ser especificado no mesmo projeto WCF. O atributo <strong>Name</strong> é o tipo (classe) do serviço, e ele precisa ser encontrado no caminho especificado. No elemento <strong>endpoint</strong>, o ABC é incluído: address, binding e contract.</p>
<h2>Expondo Metadados</h2>
<p>Endpoints de metadados começam com o prefixo <strong>mex</strong>, abreviação para <strong>metadata exchange</strong>. Atualmente há quatro tipos de endpoints: <em>mexHttpBinding</em>, <em>mexHttpsBinding</em>, <em>mexNamedPipeBinding</em> e <em>mexMsmqBinding</em>. Cada um corresponde para o binding do serviço, mas você pode expor todos se necessário.</p>
<p>Vamos alterar o serviço acima para o binding wsHttpBinding e adicionar um endpoint de metadados mexHttpBinding. O XML de configuração ficaria assim:</p>
<p><code>&lt;service name=&quot;Samples.WCF.Services.TestService&quot;&gt;<br />
 &lt;endpoint address=&quot;http://www.williamgryan.mobi/samples/487&quot;<br />
 binding=&quot;wsHttpBinding&quot; bindingConfiguration=&quot;&quot; name=&quot;WsHttp&quot;<br />
 contract=&quot;Samples.WCF.Services.ITestService&quot; /&gt;<br />
<strong> &lt;endpoint binding=&quot;mexHttpBinding&quot; bindingConfiguration=&quot;&quot;<br />
 name=&quot;Mex&quot; contract=&quot;IMetadataExchange&quot; /&gt;</strong><br />
</service></code></p>
<p>Com isso, a troca de metados está habilitada, permitindo que os clients vejam o WSDL para obter informações do serviço.</p>
<h2>Configurando ServiceBehaviors e EndpointBehaviors</h2>
<p>Você especificar comportamentos (behaviors) específicos que habilitam opções avançadas de segurança ou performance, por exemplo. EndpointBehaviors habilitam a configuração dos endpoints, como clientCredentials, o batch de transação, o serializer do DataContract, e muito mais. ServiceBehaviors controlam aspectos do serviço em um nível granular.</p>
<p>Usando o WCF Service Configuration Editor, basta ir para o nodo Advanced, depois Service Behaviors ou Endpoint Behaviors e adicionar um novo behavior. A tela seguintes mostra uma lista dos behaviors disponíveis:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/6.png" alt="select behaviors" width="432" height="579" class="alignnone size-full wp-image-403" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/6.png 432w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/6-224x300.png 224w" sizes="(max-width: 432px) 100vw, 432px" /></p>
<p>Basta selecionar os behaviors desejados e clicar em Add. O XML ficará parecido com o seguinte:</p>
<p><code>&lt;system.serviceModel&gt;<br />
 <strong>&lt;behaviors&gt;<br />
 &lt;serviceBehaviors&gt;<br />
 &lt;behavior name=&quot;Debug&quot;&gt;<br />
 &lt;serviceDebug /&gt;<br />
 &lt;/behavior&gt;<br />
 &lt;/serviceBehaviors&gt;<br />
 &lt;/behaviors&gt;</strong><br />
 &lt;services&gt;<br />
 &lt;service <strong>behaviorConfiguration=&quot;Debug&quot;</strong> name=&quot;Samples.WCF.Services.<br />
TestService&quot;&gt;<br />
 &lt;endpoint address=http://www.williamgryan.mobi/samples/487<br />
 binding=&quot;wsHttpBinding&quot; bindingConfiguration=&quot;&quot; name=&quot;WsHttp&quot;<br />
 contract=&quot;Samples.WCF.Services.ITestService&quot; /&gt;<br />
 &lt;endpoint binding=&quot;mexHttpBinding&quot; bindingConfiguration=&quot;&quot; name=&quot;Mex&quot;<br />
 contract=&quot;IMetadataExchange&quot; /&gt;<br />
 &lt;/service&gt;<br />
 &lt;/services&gt;<br />
&lt;/system.serviceModel&gt;</code></p>
<p>O link entre o behavior configurado e o serviço está no atributo behaviorConfiguration do service, conforme destacado acima.</p>
<p>Outro item provável de cair no exame é o ProtocolMapping. Esse elemento permite que você relacione bindings aos protocolos de transporte:</p>
<p><code>&lt;protocolMapping&gt;<br />
 &lt;add scheme=&quot;http&quot; binding=&quot;basicHttpBinding&quot;/&gt;<br />
 &lt;add scheme=&quot;net.tcp&quot; binding=&quot;netTcpBinding&quot;/&gt;<br />
 &lt;add scheme=&quot;net.pipe&quot; binding=&quot;netNamedPipeBinding&quot;/&gt;<br />
 &lt;add scheme=&quot;net.msmq&quot; binding=&quot;netMsmqBinding&quot;/&gt;<br />
&lt;/protocolMapping&gt;</code></p>
<p>Isso pode ser feito tanto nos arquivos app.config de cada serviço quanto no arquivo geral da máquina de host, o machine.config.</p>
<h2>Configurando Bindings</h2>
<p>Ainda no WCF Service Configuration Editor, é possível configurar bindings. A tela Create a New Binding lista todas as opções possíveis:</p>
<p><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/7.png" alt="select binding" width="294" height="434" class="alignnone size-full wp-image-406" srcset="https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/7.png 294w, https://edneypitta.github.io/old-blog/wp-content/uploads/2016/02/7-203x300.png 203w" sizes="(max-width: 294px) 100vw, 294px" /></p>
<p>Após criar um wsHttpBinding, é necessário definir um ProtocolMapping para o protocolo wsHttp. É possível fazer isso selecionando o nodo Protocol Mapping, clicando em New, e informando o Scheme (wsHttp), o Binding (wsHttpBinding) e o Binding Configuration, com o nome do binding criado anteriormente. A configuração no XML ficaria assim:</p>
<p><code>&lt;protocolMapping&gt;<br />
 &lt;add scheme=&quot;wsHttp&quot; binding=&quot;wsHttpBinding&quot;<br />
 bindingConfiguration=&quot;wsHttpBindingConfigSample&quot; /&gt;<br />
&lt;/protocolMapping&gt;<br />
&lt;bindings&gt;<br />
 &lt;wsHttpBinding&gt;<br />
 &lt;binding name=&quot;wsHttpBindingConfigSample&quot; /&gt;<br />
 &lt;/wsHttpBinding&gt;<br />
&lt;/bindings&gt;</code></p>
<p>Nesse caso, configuramos o protocolo wsHttp pelo Protocol Mapping para responder nesse binding. Um cenário mais real seria editar um protocolo já configurado por padrão para responder no nosso binding criado. </p>
<p>Vamos fazer isso com o protocolo http. Pelo editor, basta ir em Protocol Mapping, selecionar o Scheme http e Edit. Após configurar para o nosso binding (wsHttpBinding), o arquivo de configuração ficará assim:</p>
<p><code>&lt;protocolMapping&gt;<br />
 &lt;remove scheme=&quot;http&quot; /&gt;<br />
 &lt;add scheme=&quot;http&quot; binding=&quot;wsHttpBinding&quot;<br />
 bindingConfiguration=&quot;wsHttpBindingConfigSample&quot; /&gt;<br />
&lt;/protocolMapping&gt;</code></p>
<p>Isso é tudo para esse objetivo 🙂<br />
Para o exame, certifique-se de olhar os exemplos em XML acima e memorizar os atributos possíveis para cada elemento.</p>
<p>O próximo post será sobre o objetivo 3.3, <strong><a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-3-configure-wcf-services-by-using-the-api/">Configure WCF services by using the API</a></strong>.<br />
Até lá!</p>

				<p><a class="btn btn-default read-more" href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-3-2-configure-wcf-services-by-using-configuration-settings/" title="Certificação Microsoft 70-487: Objetivo 3.2 – Configure WCF services by using configuration settings">Leia Mais</a></p>

							</div><!-- .entry-content -->
					</div>
	</div>
</article><!-- #post-## -->

			
				<nav class="navigation paging-navigation" role="navigation">
		<h1 class="screen-reader-text">Navegação de Posts</h1>
		<div class="nav-links">

						<div class="nav-previous"> <a href="https://edneypitta.github.io/old-blog/2016/02/page/2/" ><i class="fa fa-chevron-left"></i> Anteriores</a></div>
			
			
		</div><!-- .nav-links -->
	</nav><!-- .navigation -->
	
		
		</main><!-- #main -->
	</section><!-- #primary -->

</div>
	<div id="secondary" class="widget-area col-sm-12 col-md-4" role="complementary">
		<div class="well">
						<aside id="text-3" class="widget widget_text">			<div class="textwidget"><a href="https://edneypitta.github.io/old-blog/sobre/"><img src="https://edneypitta.github.io/old-blog/wp-content/uploads/2015/08/IMG-20150829-WA00012-e1440915174271-150x150.jpg"  width="150" height="150" class="aligncenter size-thumbnail wp-image-93" style="border-radius: 80px;" />
<h2 style="text-align:center;">Edney Pitta</h2></a>
<div style="text-align: center;">Desenvolvedor de Software @ Lambda3</div>
<div style="margin-top:20px;text-align:center;"><a href="https://edneypitta.github.io/old-blog/sobre/"><button class="btn btn-danger btn-lg " >SOBRE MIM</button></a></div></div>
		</aside><aside id="search-2" class="widget widget_search">
<form role="search" method="get" class="form-search" action="https://edneypitta.github.io/old-blog/">
  <div class="input-group">
  	<label class="screen-reader-text" for="s">Search for:</label>
    <input type="text" class="form-control search-query" placeholder="Procurar&hellip;" value="" name="s" title="Search for:" />
    <span class="input-group-btn">
      <button type="submit" class="btn btn-default" name="submit" id="searchsubmit" value="Search"><span class="glyphicon glyphicon-search"></span></button>
    </span>
  </div>
</form></aside>		<aside id="recent-posts-3" class="widget widget_recent_entries">		<h3 class="widget-title">Posts recentes</h3>		<ul>
					<li>
				<a href="https://edneypitta.github.io/old-blog/migrando-um-projeto-asp-net-core-rc-1-para-rc-2/">Migrando um projeto ASP.NET Core RC 1 para RC 2</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-486-developing-asp-net-mvc-web-applications/">Certificação Microsoft 70-486: Developing ASP.NET MVC Web Applications</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-480-programming-in-html5-with-javascript-and-css3/">Certificação Microsoft 70-480: Programming in HTML5 with JavaScript and CSS3</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-resultado/">Certificação Microsoft 70-487 &#8211; Resultado</a>
						</li>
					<li>
				<a href="https://edneypitta.github.io/old-blog/certificacao-microsoft-70-487-objetivo-5-6-share-assemblies-between-multiple-applications-and-servers/">Certificação Microsoft 70-487: Objetivo 5.6 – Share assemblies between multiple applications and servers</a>
						</li>
				</ul>
		</aside>		<aside id="annual_archive_widget-2" class="widget Annual_Archive_Widget"><h3 class="widget-title">Arquivo</h3>	<ul>
		<li><a href='https://edneypitta.github.io/old-blog/2016/06/'>junho 2016</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/05/'>maio 2016</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/04/'>abril 2016</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/03/'>março 2016</a>&nbsp;(10)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/02/'>fevereiro 2016</a>&nbsp;(11)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2016/01/'>janeiro 2016</a>&nbsp;(10)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/12/'>dezembro 2015</a>&nbsp;(3)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/11/'>novembro 2015</a>&nbsp;(3)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/10/'>outubro 2015</a>&nbsp;(1)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/09/'>setembro 2015</a>&nbsp;(5)</li>
	<li><a href='https://edneypitta.github.io/old-blog/2015/08/'>agosto 2015</a>&nbsp;(2)</li>
	</ul>
	</aside>		</div>
	</div><!-- #secondary -->
			</div><!-- close .*-inner (main-content or sidebar, depending if sidebar is used) -->
		</div><!-- close .row -->
	</div><!-- close .container -->
</div><!-- close .site-content -->

	<div id="footer-area">
		<div class="container footer-inner">
			<div class="row">
				
				</div>
		</div>

		<footer id="colophon" class="site-footer" role="contentinfo">
			<div class="site-info container">
				<div class="row">
										<nav role="navigation" class="col-md-6">
						<ul id="menu-social-1" class="nav footer-nav clearfix"><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-20"><a href="https://br.linkedin.com/in/edneypitta"><i class="fa fa-linkedin-square"></i></a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-22"><a href="https://www.facebook.com/edneypitta"><i class="fa fa-facebook-square"></i></a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-23"><a href="https://twitter.com/edneypitta"><i class="fa fa-twitter-square"></i></a></li>
<li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-24"><a href="https://edneypitta.github.io/old-blog/feed/"><i class="fa fa-rss"></i></a></li>
<li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-27"><a href="https://edneypitta.github.io/old-blog/sobre/"><i class="fa fa-info-circle"></i></a></li>
</ul>					</nav>
					<div class="copyright col-md-6">
						<a rel="license" href="http://creativecommons.org/licenses/by/2.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/2.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/2.0/">Creative Commons Attribution 2.0 Generic License</a>.						Theme by <a href="http://colorlib.com/" target="_blank">Colorlib</a> Powered by <a href="http://wordpress.org/" target="_blank">WordPress</a>					</div>
				</div>
			</div><!-- .site-info -->
			<div class="scroll-to-top"><i class="fa fa-angle-up"></i></div><!-- .scroll-to-top -->
		</footer><!-- #colophon -->
	</div>
</div><!-- #page -->

<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/themes/sparkling/inc/js/skip-link-focus-fix.js?ver=20140222'></script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-includes/js/wp-embed.min.js?ver=4.8.2'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var countVars = {"disqusShortname":"edneypitta"};
/* ]]> */
</script>
<script type='text/javascript' src='https://edneypitta.github.io/old-blog/wp-content/plugins/disqus-comment-system/media/js/count.js?ver=4.8.2'></script>

</body>
</html>